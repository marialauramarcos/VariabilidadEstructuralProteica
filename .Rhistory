if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoreticalCM(family,
p.ref,
chain.p.ref,
n.mut.p,
R0,
rotate,
heme,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
tolerance)
}
}
}
}
}
betas.fname.id <- paste(family, "_", p.ref, "_R0_", R0, sep = "")
all.betas <- read.csv(file.path(out.dir, paste(betas.fname.id, "_out_all.betas.csv", sep = "")))
regimens <- c("strong.sel", "medium.sel", "weak.sel", "no.sel")
all.betas
b
regimens[all.betas == b] != "medium.sel"
regimens[all.betas == b] != "weak.sel"
# Description:
#
# This is the main program of the project. The program simulates multiple mutants of a given protein using the "Linearly Forced -
# Elastic Network Model" (LF-ENM) with different selection regimens according to the "Stress Model". The program also
# analyzes the multiple alignment of the family to which the protein belongs and calculates measures
# of variabilty of theoretical and experimental data.
# The difference between this program and "MainProgram.R" is that, in this case, the model considers two sites per
# aminoacid, the CA and the center of mass of the side chain (CM).
# For the LF - ENM, only CMs are mutated.
#
# To run the program it is necessary to previously fill the input ("input_MainProgram.csv") with the following information:
#
#    - family: The family of the protein to mutate. It can be "globins", "serinProteases",
#    "snakesToxin", "sh3", "fabp", "rrm", "phoslip" or "cys".
#    - p.ref: The pdb code (pdbid) of the protein to mutate (example: "1a6m"). The protein must be a member of
#    the selected family. This pdbid must not be included in the dataset ("DATA/family_dataset.csv").
#    - chain.p.ref: The chain of p.ref in the pdb file obtained from Homstrad.
#    - n.mut.p: The number of mutants to generate for each member of the family. For example, if the family has 20
#    members, the program generates n.mut.p x 20 mutants.
#    - fmax: Argument for "LFENM". It is the maximun value for the forces that model the mutations.
#    - R0: the Cut-off for the "ANM" (Anisotropic Network Model) that represents the proteins.
#    - rotate: It can be "TRUE" or "FALSE". If it is "TRUE", r.p.2 is rotated in order to minimize RMSD with r.p.ref.
#    - heme: Argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - calculate.betas: It can be "TRUE" or "FALSE". If it is "TRUE", the program calculates betas of the "Stress Model".
#    - analyze.family: It can be "TRUE" or "FALSE". If it is "TRUE", the program analyzes the family.
#    - generate.mutants: It can be "TRUE" or "FALSE". If it is "TRUE", the program generates new mutants.
#    - K.analysis: It can be "K" or "Keff". For "K" or "Keff", the analysis is based on normal modes of "K" or "Keff"
#    respectibly.
### PROGRAM ###
# Remove objects from the workspace
rm(list = ls())
# Load packages
library(bio3d)
library(seqinr)
# Set Elastic Network Model: "ANM" or "pfANM"
model <- "ANM"
# Data dir
data.dir <- "DATA"
# Output dir
if (model == "ANM") out.dir <- "OUT/out_subset_CM_ANM"
if (model == "pfANM") out.dir <- "OUT/out_subset_CM_pfANM"
# General parameters
tolerance = 1e-10
# Function filenames
AnalyzeExperimentalTheoreticalCM.fname <- "FUNCTIONS/AnalyzeExperimentalTheoreticalCM.R"
AnalyzeFamily.fname <- "FUNCTIONS/AnalyzeFamily.R"
AnalyzeAlignment.fname <- "FUNCTIONS/AnalyzeAlignment.R"
GenerateMutantsCM.fname <- "FUNCTIONS/GenerateMutantsCM.R"
ReadFasta.fname <- "FUNCTIONS/ReadFasta.R"
ReadCA.fname <- "FUNCTIONS/ReadCA.R"
ReadHeme.fname <- "FUNCTIONS/ReadHeme.R"
CalculateSideChainCM.fname <- "FUNCTIONS/CalculateSideChainCM.R"
CalculateENMKeff.fname <- "FUNCTIONS/CalculateENMKeff.R"
CalculateENMK.fname <- "FUNCTIONS/CalculateENMK.R"
CalculateVariability.fname <- "FUNCTIONS/CalculateVariability.R"
WindowsRMSD.fname <- "FUNCTIONS/WindowsRMSD.R"
if (model == "ANM") {
CalculateBetasCM.fname <- "FUNCTIONS/CalculateBetasCM.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKij.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForce.R"
}
if (model == "pfANM") {
CalculateBetasCM.fname <- "FUNCTIONS/CalculateBetasCMPFANM.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKijPFANM.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForcePFANM.R"
}
# Source functions
source(AnalyzeExperimentalTheoreticalCM.fname)
source(AnalyzeFamily.fname)
source(AnalyzeAlignment.fname)
source(GenerateMutantsCM.fname)
source(ReadFasta.fname)
source(ReadCA.fname)
source(ReadHeme.fname)
source(CalculateSideChainCM.fname)
source(CalculateENMKeff.fname)
source(CalculateENMK.fname)
source(CalculateVariability.fname)
source(WindowsRMSD.fname)
source(CalculateBetasCM.fname)
source(CalculateKij.fname)
source(CalculateForce.fname)
# Read input
input.fname <- file.path("input_MainProgram.csv")
input <- read.csv(input.fname)
# Start a loop to analyze each family
for (f in (1:nrow(input))) {
family <- as.character(input$family)[f]
p.ref <- as.character(input$p.ref)[f]
chain.p.ref <- as.character(input$chain.p.ref)[f]
n.mut.p = input$n.mut.p[f]
fmax = input$fmax[f]
R0 = input$R0[f]
rotate <- input$rotate[f]
heme <- input$heme[f]
calculate.betas <- input$calculate.betas[f]
analyze.family <- input$analyze.family[f]
generate.mutants <- input$generate.mutants[f]
analyze.experimental.theoretical <- input$analyze.experimental.theoretical[f]
K.analysis <- input$K.analysis[f]
print(family)
# Analyze the alignment of the family
if (analyze.family == "TRUE") {
AnalyzeFamily(family,
p.ref,
data.dir,
out.dir)
}
# Generate id for betas output filename
betas.fname.id <- paste(family, "_", p.ref, "_R0_", R0, sep = "")
# Calculate betas of the "Stress Model"
if (calculate.betas == "TRUE") {
CalculateBetasCM(chain.p.ref,
fmax,
R0,
heme,
data.dir,
out.dir,
betas.fname.id,
tolerance)
}
# Read betas and stablish selection regimens
all.betas <- read.csv(file.path(out.dir, paste(betas.fname.id, "_out_all.betas.csv", sep = "")))
regimens <- c("strong.sel", "medium.sel", "weak.sel", "no.sel")
# Start a loop for each beta
for (b in all.betas)  {
if (regimens[all.betas == b] != "medium.sel") {
if (regimens[all.betas == b] != "weak.sel") {
# Generate ids for output filenames
mut.fname.id <- paste(family, "_R0_", R0, "_beta_", regimens[all.betas == b], sep = "")
analysis.fname.id <- paste(mut.fname.id, "_K.analysis_", K.analysis, sep = "")
# Generate mutants
if (generate.mutants == "TRUE") {
GenerateMutantsCM(family,
chain.p.ref,
n.mut.p,
fmax,
R0,
b,
heme,
data.dir,
out.dir,
mut.fname.id,
tolerance)
}
# Calculate measures of variability of theoretical and experimental proteins
if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoreticalCM(family,
p.ref,
chain.p.ref,
n.mut.p,
R0,
rotate,
heme,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
tolerance)
}
}
}
}
}
# Filenames
dataset.fname <- file.path(data.dir, paste(family, "_dataset.csv", sep = ""))
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
pdbs.fname <- file.path(data.dir, paste(family, "_coordinates.pdb", sep = ""))
m.n.aligned.fname <- file.path(out.dir, paste(family, "_out_m.n.aligned.csv", sep = ""))
m.aligned.p.ref.index.fname <- file.path(out.dir, paste(family, "_out_m.aligned.p.ref.index.csv", sep = ""))
m.aligned.p.2.index.fname <- file.path(out.dir, paste(family, "_out_m.aligned.p.2.index.csv", sep = ""))
m.not.aligned.p.ref.index.fname <- file.path(out.dir, paste(family, "_out_m.not.aligned.p.ref.index.csv", sep = ""))
m.not.aligned.p.2.index.fname <- file.path(out.dir, paste(family, "_out_m.not.aligned.p.2.index.csv", sep = ""))
# Read the dataset
dataset <- read.csv(dataset.fname)
pdbid.dataset <- as.character(dataset$pdbid)
chain <- as.character(dataset$chain)
n.prot = length(pdbid.dataset)
### THEORETICAL ###
# Filenames
theo.r.p.ref.fname <- file.path(out.dir, paste(mut.fname.id, "_out_r.p.ref.csv", sep = ""))
m.r.mut.fname <- file.path(out.dir, paste(mut.fname.id, "_out_m.r.mut.csv", sep = ""))
# Read coordinates
theo.r.p.ref = read.csv(theo.r.p.ref.fname)$x
m.r.mut = read.csv(m.r.mut.fname)
n.sites.p.ref = length(theo.r.p.ref)/3
n.mut = ncol(m.r.mut)
r.CM.p.ref = CalculateSideChainCM(pdb.fname, chain.p.ref)
n.CM = ncol(r.CM.p.ref)
theo.r.p.ref = c(theo.r.p.ref, as.vector(r.CM.p.ref))
n.sites.tot = length(theo.r.p.ref)/3
# Create matrices to save measures of variability of each mutant
m.theo.Pn = matrix(nrow = n.mut, ncol = 3 * n.sites.p.ref)
m.theo.va = matrix(nrow = n.mut, ncol = 3 * n.sites.p.ref)
m.theo.dr.squarei = matrix(nrow = n.mut, ncol = n.sites.p.ref)
m.theo.dr.squarei.windows.rot = matrix(nrow = n.mut, ncol = n.sites.p.ref)
m.theo.norm.dr.squarei = matrix(nrow = n.mut, ncol = n.sites.p.ref)
m.theo.norm.dr.squarei.windows.rot = matrix(nrow = n.mut, ncol = n.sites.p.ref)
m.theo.smooth.dr.squarei = matrix(nrow = n.mut, ncol = n.sites.p.ref)
m.theo.smooth.norm.dr.squarei = matrix(nrow = n.mut, ncol = n.sites.p.ref)
m.theo.sum.dif.dist = matrix(nrow = n.mut, ncol = n.sites.p.ref)
kij = CalculateENMK(matrix(theo.r.p.ref[1:(3 * n.sites.p.ref)], nrow = 3), CalculateKij, R0, tolerance)$kij
# Read pdb of exp.p.ref
exp.r.p.ref = theo.r.p.ref
if(heme == "TRUE") {
n.aa.p.ref = n.sites.p.ref - 5
} else {
n.aa.p.ref = n.sites.p.ref
}
# Read indexes files
m.n.aligned = read.csv(m.n.aligned.fname)
m.aligned.p.ref.index = read.csv(m.aligned.p.ref.index.fname)
m.aligned.p.2.index = read.csv(m.aligned.p.2.index.fname)
m.not.aligned.p.ref.index = read.csv(m.not.aligned.p.ref.index.fname)
m.not.aligned.p.2.index = read.csv(m.not.aligned.p.2.index.fname)
# Create matrices to save measures of variability of each mutant
m.exp.Pn = matrix(nrow = n.prot, ncol = 3 * (n.sites.p.ref))
m.exp.va = matrix(nrow = n.prot, ncol = 3 * (n.sites.p.ref))
m.exp.dr.squarei = matrix(nrow = n.prot, ncol = (n.sites.p.ref))
m.exp.dr.squarei.windows.rot = matrix(nrow = n.mut, ncol = n.sites.p.ref)
m.exp.norm.dr.squarei = matrix(nrow = n.prot, ncol = (n.sites.p.ref))
m.exp.norm.dr.squarei.windows.rot = matrix(nrow = n.prot, ncol = n.sites.p.ref)
m.exp.smooth.dr.squarei = matrix(nrow = n.prot, ncol = (n.sites.p.ref))
m.exp.smooth.norm.dr.squarei = matrix(nrow = n.prot, ncol = (n.sites.p.ref))
m.exp.sum.dif.dist = matrix(nrow = n.prot, ncol = n.sites.p.ref)
# Start a loop to evaluate each protein of the family
for (P in (1:n.prot)) {
print(P)
# Get aligned and not aligned indexes
n.aligned = as.numeric(m.n.aligned[P, ])
aligned.p.ref.index = as.numeric(m.aligned.p.ref.index[P, !is.na(m.aligned.p.ref.index[P, ])])
aligned.p.2.index = as.numeric(m.aligned.p.2.index[P, !is.na(m.aligned.p.2.index[P, ])])
not.aligned.p.ref.index = as.numeric(m.not.aligned.p.ref.index[P, !is.na(m.not.aligned.p.ref.index[P, ])])
not.aligned.p.2.index = as.numeric(m.not.aligned.p.2.index[P, !is.na(m.not.aligned.p.2.index[P, ])])
# Read PDB of exp.p.2
chain.p.2 <- chain[[P]]
exp.pdb.p.2 = ReadCA(pdbs.fname, chain.p.2)
exp.r.p.2 = exp.pdb.p.2$xyz.calpha
exp.n.aa.p.2 = ncol(exp.r.p.2)
# Calculate heme coordinates, add them to CA´s coordinates and calculate the number of sites and not aligned indexes
if (heme == "TRUE") {
exp.r.heme.p.2 = ReadHeme(pdbs.fname, chain.p.2)
exp.r.p.2 = cbind(exp.r.p.2, exp.r.heme.p.2)
exp.n.sites.p.2 = ncol(exp.r.p.2)
aligned.p.ref.index <- c(aligned.p.ref.index, t(seq((n.aa.p.ref + 1), n.sites.p.ref)))
aligned.p.2.index <- c(aligned.p.2.index, t(seq((exp.n.aa.p.2 + 1), exp.n.sites.p.2)))
}
# Add indexes of CMs to not aligned
not.aligned.p.ref.index <- c(not.aligned.p.ref.index, t(seq((n.sites.p.ref + 1), n.sites.tot)))
}
P = 1
# Get aligned and not aligned indexes
n.aligned = as.numeric(m.n.aligned[P, ])
aligned.p.ref.index = as.numeric(m.aligned.p.ref.index[P, !is.na(m.aligned.p.ref.index[P, ])])
aligned.p.2.index = as.numeric(m.aligned.p.2.index[P, !is.na(m.aligned.p.2.index[P, ])])
not.aligned.p.ref.index = as.numeric(m.not.aligned.p.ref.index[P, !is.na(m.not.aligned.p.ref.index[P, ])])
not.aligned.p.2.index = as.numeric(m.not.aligned.p.2.index[P, !is.na(m.not.aligned.p.2.index[P, ])])
# Read PDB of exp.p.2
chain.p.2 <- chain[[P]]
exp.pdb.p.2 = ReadCA(pdbs.fname, chain.p.2)
exp.r.p.2 = exp.pdb.p.2$xyz.calpha
exp.n.aa.p.2 = ncol(exp.r.p.2)
# Calculate heme coordinates, add them to CA´s coordinates and calculate the number of sites and not aligned indexes
if (heme == "TRUE") {
exp.r.heme.p.2 = ReadHeme(pdbs.fname, chain.p.2)
exp.r.p.2 = cbind(exp.r.p.2, exp.r.heme.p.2)
exp.n.sites.p.2 = ncol(exp.r.p.2)
aligned.p.ref.index <- c(aligned.p.ref.index, t(seq((n.aa.p.ref + 1), n.sites.p.ref)))
aligned.p.2.index <- c(aligned.p.2.index, t(seq((exp.n.aa.p.2 + 1), exp.n.sites.p.2)))
}
# Add indexes of CMs to not aligned
not.aligned.p.ref.index <- c(not.aligned.p.ref.index, t(seq((n.sites.p.ref + 1), n.sites.tot)))
# Calculate measures of variability
exp.variability = CalculateVariability(as.vector(exp.r.p.ref),
as.vector(exp.r.p.2),
n.sites.p.ref,
exp.n.sites.p.2,
aligned.p.ref.index,
aligned.p.2.index,
not.aligned.p.ref.index,
not.aligned.p.2.index,
R0,
rotate,
K.analysis,
tolerance)
exp.n.sites.p.2
if (heme == "TRUE") {
exp.r.heme.p.2 = ReadHeme(pdbs.fname, chain.p.2)
exp.r.p.2 = cbind(exp.r.p.2, exp.r.heme.p.2)
exp.n.sites.p.2 = ncol(exp.r.p.2)
aligned.p.ref.index <- c(aligned.p.ref.index, t(seq((n.aa.p.ref + 1), n.sites.p.ref)))
aligned.p.2.index <- c(aligned.p.2.index, t(seq((exp.n.aa.p.2 + 1), exp.n.sites.p.2)))
} else {
exp.n.sites.p.2 = exp.n.aa.p.2
}
exp.variability = CalculateVariability(as.vector(exp.r.p.ref),
as.vector(exp.r.p.2),
n.sites.p.ref,
exp.n.sites.p.2,
aligned.p.ref.index,
aligned.p.2.index,
not.aligned.p.ref.index,
not.aligned.p.2.index,
R0,
rotate,
K.analysis,
tolerance)
as.vector(exp.r.p.2)
as.vector(exp.r.p.2)/2
length(as.vector(exp.r.p.2))/2
as.vector(exp.r.p.ref)
length(as.vector(exp.r.p.ref))/3
length(as.vector(exp.r.p.2))/3
aligned.p.ref.index
length(as.vector(exp.r.p.ref))/3
length(as.vector(exp.r.p.ref))/3/2
n.sites.p.ref
n.sites.p.ref
# Description:
#
# This is the main program of the project. The program simulates multiple mutants of a given protein using the "Linearly Forced -
# Elastic Network Model" (LF-ENM) with different selection regimens according to the "Stress Model". The program also
# analyzes the multiple alignment of the family to which the protein belongs and calculates measures
# of variabilty of theoretical and experimental data.
# The difference between this program and "MainProgram.R" is that, in this case, the model considers two sites per
# aminoacid, the CA and the center of mass of the side chain (CM).
# For the LF - ENM, only CMs are mutated.
#
# To run the program it is necessary to previously fill the input ("input_MainProgram.csv") with the following information:
#
#    - family: The family of the protein to mutate. It can be "globins", "serinProteases",
#    "snakesToxin", "sh3", "fabp", "rrm", "phoslip" or "cys".
#    - p.ref: The pdb code (pdbid) of the protein to mutate (example: "1a6m"). The protein must be a member of
#    the selected family. This pdbid must not be included in the dataset ("DATA/family_dataset.csv").
#    - chain.p.ref: The chain of p.ref in the pdb file obtained from Homstrad.
#    - n.mut.p: The number of mutants to generate for each member of the family. For example, if the family has 20
#    members, the program generates n.mut.p x 20 mutants.
#    - fmax: Argument for "LFENM". It is the maximun value for the forces that model the mutations.
#    - R0: the Cut-off for the "ANM" (Anisotropic Network Model) that represents the proteins.
#    - rotate: It can be "TRUE" or "FALSE". If it is "TRUE", r.p.2 is rotated in order to minimize RMSD with r.p.ref.
#    - heme: Argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - calculate.betas: It can be "TRUE" or "FALSE". If it is "TRUE", the program calculates betas of the "Stress Model".
#    - analyze.family: It can be "TRUE" or "FALSE". If it is "TRUE", the program analyzes the family.
#    - generate.mutants: It can be "TRUE" or "FALSE". If it is "TRUE", the program generates new mutants.
#    - K.analysis: It can be "K" or "Keff". For "K" or "Keff", the analysis is based on normal modes of "K" or "Keff"
#    respectibly.
### PROGRAM ###
# Remove objects from the workspace
rm(list = ls())
# Load packages
library(bio3d)
library(seqinr)
# Set Elastic Network Model: "ANM" or "pfANM"
model <- "ANM"
# Data dir
data.dir <- "DATA"
# Output dir
if (model == "ANM") out.dir <- "OUT/out_subset_CM_ANM"
if (model == "pfANM") out.dir <- "OUT/out_subset_CM_pfANM"
# General parameters
tolerance = 1e-10
# Function filenames
AnalyzeExperimentalTheoreticalCM.fname <- "FUNCTIONS/AnalyzeExperimentalTheoreticalCM.R"
AnalyzeFamily.fname <- "FUNCTIONS/AnalyzeFamily.R"
AnalyzeAlignment.fname <- "FUNCTIONS/AnalyzeAlignment.R"
GenerateMutantsCM.fname <- "FUNCTIONS/GenerateMutantsCM.R"
ReadFasta.fname <- "FUNCTIONS/ReadFasta.R"
ReadCA.fname <- "FUNCTIONS/ReadCA.R"
ReadHeme.fname <- "FUNCTIONS/ReadHeme.R"
CalculateSideChainCM.fname <- "FUNCTIONS/CalculateSideChainCM.R"
CalculateENMKeff.fname <- "FUNCTIONS/CalculateENMKeff.R"
CalculateENMK.fname <- "FUNCTIONS/CalculateENMK.R"
CalculateVariability.fname <- "FUNCTIONS/CalculateVariability.R"
WindowsRMSD.fname <- "FUNCTIONS/WindowsRMSD.R"
if (model == "ANM") {
CalculateBetasCM.fname <- "FUNCTIONS/CalculateBetasCM.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKij.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForce.R"
}
if (model == "pfANM") {
CalculateBetasCM.fname <- "FUNCTIONS/CalculateBetasCMPFANM.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKijPFANM.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForcePFANM.R"
}
# Source functions
source(AnalyzeExperimentalTheoreticalCM.fname)
source(AnalyzeFamily.fname)
source(AnalyzeAlignment.fname)
source(GenerateMutantsCM.fname)
source(ReadFasta.fname)
source(ReadCA.fname)
source(ReadHeme.fname)
source(CalculateSideChainCM.fname)
source(CalculateENMKeff.fname)
source(CalculateENMK.fname)
source(CalculateVariability.fname)
source(WindowsRMSD.fname)
source(CalculateBetasCM.fname)
source(CalculateKij.fname)
source(CalculateForce.fname)
# Read input
input.fname <- file.path("input_MainProgram.csv")
input <- read.csv(input.fname)
# Start a loop to analyze each family
for (f in (1:nrow(input))) {
family <- as.character(input$family)[f]
p.ref <- as.character(input$p.ref)[f]
chain.p.ref <- as.character(input$chain.p.ref)[f]
n.mut.p = input$n.mut.p[f]
fmax = input$fmax[f]
R0 = input$R0[f]
rotate <- input$rotate[f]
heme <- input$heme[f]
calculate.betas <- input$calculate.betas[f]
analyze.family <- input$analyze.family[f]
generate.mutants <- input$generate.mutants[f]
analyze.experimental.theoretical <- input$analyze.experimental.theoretical[f]
K.analysis <- input$K.analysis[f]
print(family)
# Analyze the alignment of the family
if (analyze.family == "TRUE") {
AnalyzeFamily(family,
p.ref,
data.dir,
out.dir)
}
# Generate id for betas output filename
betas.fname.id <- paste(family, "_", p.ref, "_R0_", R0, sep = "")
# Calculate betas of the "Stress Model"
if (calculate.betas == "TRUE") {
CalculateBetasCM(chain.p.ref,
fmax,
R0,
heme,
data.dir,
out.dir,
betas.fname.id,
tolerance)
}
# Read betas and stablish selection regimens
all.betas <- read.csv(file.path(out.dir, paste(betas.fname.id, "_out_all.betas.csv", sep = "")))
regimens <- c("strong.sel", "medium.sel", "weak.sel", "no.sel")
# Start a loop for each beta
for (b in all.betas)  {
if (regimens[all.betas == b] != "medium.sel") {
if (regimens[all.betas == b] != "weak.sel") {
# Generate ids for output filenames
mut.fname.id <- paste(family, "_R0_", R0, "_beta_", regimens[all.betas == b], sep = "")
analysis.fname.id <- paste(mut.fname.id, "_K.analysis_", K.analysis, sep = "")
# Generate mutants
if (generate.mutants == "TRUE") {
GenerateMutantsCM(family,
chain.p.ref,
n.mut.p,
fmax,
R0,
b,
heme,
data.dir,
out.dir,
mut.fname.id,
tolerance)
}
# Calculate measures of variability of theoretical and experimental proteins
if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoreticalCM(family,
p.ref,
chain.p.ref,
n.mut.p,
R0,
rotate,
heme,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
tolerance)
}
}
}
}
}
f
family
