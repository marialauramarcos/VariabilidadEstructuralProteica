n.mut.p,
fmax,
R0,
heme,
natural.selection,
data.dir,
out.dir,
mut.fname.id,
TOLERANCE)
}
# Analyze measures of variability of experimental proteins and simulated mutants.
if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoretical(family,
exp.chain.p.ref,
n.mut.p,
R0,
core,
rotate,
heme,
natural.selection,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
TOLERANCE)
}
}
#  Generate a report.
#  rmarkdown::render('Report.Rmd',
#                    output_file = paste("report_", analysis.fname.id, ".html", sep = ''))
#}
# This is the main program of the project. The program simulates mutants of a given protein, analyzes the multiple
# alignment of the family to which the protein belongs, calculates measures of variabilty of theoretical and
# experimental data, compares them, and generates a report.
# To run the program it is necessary to fill the input file ("input.csv") with the following information:
#
#    - family: the family of the protein to mutate. It can be "globins", "serinProteases", "plastocyanins",
#    "snakesToxin", "sh3", "lipocalin", "fabp", "kinase", "rrm", "phoslip", "gluts" and "ldh".
#    - p.ref: the pdb code (pdbid) of the protein to mutate (example: "1a6m"). The protein must be a member of
#    the selected family. This pdbid must not be included in the dataset ("DATA/family_dataset.csv").
#    - exp.chain.p.ref: the chain of p.ref in the pdb file obtained from Homstrad.
#    - mut.model: mutational model. It can be "LFENM" ("Linearly Forced - Elastic Network Model") or "MND"
#    ("Multivariate Normal Distribution").
#    - n.mut.p: the number of mutants to generate for each member of the family. For example, if the family has 20
#    members, the program generates n.mut.p x 20 mutants.
#    - fmax: argument for "LFENM". It is the maximun value for the forces that model the mutations.
#    - R0: the cut-off for the ANM ("Anisotropic Network Model") that represents the proteins.
#    - rotate: it can be "TRUE" or "FALSE". If it is "TRUE", r.p.2 is rotated in order to minimize RMSD with r.p.ref.
#    - core: it can be "TRUE" or "FALSE". If it is "TRUE", the program only considers the conserved core of
#    the alignment. If it is "FALSE", the program analyzes the whole alignment.
#    - heme: argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - analyze.family: It can be "TRUE" or "FALSE". If it is "TRUE" the program analyzes the family.
#    - generate.mutants: It can be "TRUE" or "FALSE". If it is "TRUE" the program generates new mutants.
#    - natural.selection: It can be "TRUE" or "FALSE". If it is "TRUE", the mutants are calculated considering natural
#    selection. If it is "FALSE", the mutants are calculated in a random manner.
#    - K.analysis: It can be "K" or "Keff". For "K" or "Keff", the analysis is based on normal modes of "K" or "Keff"
#    respectibly.
# Remove objects.
rm(list = ls())
# Load packages.
library(bio3d)
library(flux)
library(knitr)
library(markdown)
library(MASS)
library(rmarkdown)
library(seqinr)
# Data dir.
data.dir <- "DATA"
# Output dir.
out.dir <- "OUT"
# General parameters.
TOLERANCE = 1e-10
# Functions filenames.
AnalyzeExperimentalTheoretical.fname <- "FUNCTIONS/AnalyzeExperimentalTheoretical.R"
AnalyzeFamily.fname <- "FUNCTIONS/AnalyzeFamily.R"
AnalyzeAlignment.fname <- "FUNCTIONS/AnalyzeAlignment.R"
GenerateMutants.fname <- "FUNCTIONS/GenerateMutants.R"
ReadFasta.fname <- "FUNCTIONS/ReadFasta.R"
ReadCA.fname <- "FUNCTIONS/ReadCA.R"
ReadHeme.fname <- "FUNCTIONS/ReadHeme.R"
CalculateENMKeff.fname <- "FUNCTIONS/CalculateENMKeff.R"
CalculateENMK.fname <- "FUNCTIONS/CalculateENMK.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKij.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForce.R"
CalculateVariability.fname <- "FUNCTIONS/CalculateVariability.R"
# Source functions.
source(AnalyzeExperimentalTheoretical.fname)
source(AnalyzeFamily.fname)
source(AnalyzeAlignment.fname)
source(GenerateMutants.fname)
source(ReadFasta.fname)
source(ReadCA.fname)
source(ReadHeme.fname)
source(CalculateENMKeff.fname)
source(CalculateENMK.fname)
source(CalculateKij.fname)
source(CalculateForce.fname)
source(CalculateVariability.fname)
# Read input.
input.fname <- file.path("input_MainProgram.csv")
input <- read.csv(input.fname)
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
exp.chain.p.ref <- as.character(input$exp.chain.p.ref)[a]
mut.model = input$mut.model[a]
n.mut.p = input$n.mut.p[a]
fmax = input$fmax[a]
R0 = input$R0[a]
core <- input$core[a]
rotate <- input$rotate[a]
heme <- input$heme[a]
analyze.family <- input$analyze.familiy[a]
generate.mutants <- input$generate.mutants[a]
analyze.experimental.theoretical <- input$analyze.experimental.theoretical[a]
natural.selection <- input$natural.selection[a]
K.analysis <- input$K.analysis[a]
# Generate ids for output filenames.
mut.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", natural.selection, "_R0_", R0, sep = "")
analysis.fname.id <- paste(mut.fname.id, "_core_", core, "_K.analysis_", K.analysis, sep = "")
# Analyze the alignment of the family.
if (analyze.family == "TRUE") {
AnalyzeFamily(family,
p.ref,
data.dir,
out.dir)
}
# Generate mutants.
if (generate.mutants == "TRUE") {
GenerateMutants(family,
exp.chain.p.ref,
mut.model,
n.mut.p,
fmax,
R0,
heme,
natural.selection,
data.dir,
out.dir,
mut.fname.id,
TOLERANCE)
}
# Analyze measures of variability of experimental proteins and simulated mutants.
if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoretical(family,
exp.chain.p.ref,
n.mut.p,
R0,
core,
rotate,
heme,
natural.selection,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
TOLERANCE)
}
}
#  Generate a report.
#  rmarkdown::render('Report.Rmd',
#                    output_file = paste("report_", analysis.fname.id, ".html", sep = ''))
#}
warnings()
# This is the main program of the project. The program simulates mutants of a given protein, analyzes the multiple
# alignment of the family to which the protein belongs, calculates measures of variabilty of theoretical and
# experimental data, compares them, and generates a report.
# To run the program it is necessary to fill the input file ("input.csv") with the following information:
#
#    - family: the family of the protein to mutate. It can be "globins", "serinProteases", "plastocyanins",
#    "snakesToxin", "sh3", "lipocalin", "fabp", "kinase", "rrm", "phoslip", "gluts" and "ldh".
#    - p.ref: the pdb code (pdbid) of the protein to mutate (example: "1a6m"). The protein must be a member of
#    the selected family. This pdbid must not be included in the dataset ("DATA/family_dataset.csv").
#    - exp.chain.p.ref: the chain of p.ref in the pdb file obtained from Homstrad.
#    - mut.model: mutational model. It can be "LFENM" ("Linearly Forced - Elastic Network Model") or "MND"
#    ("Multivariate Normal Distribution").
#    - n.mut.p: the number of mutants to generate for each member of the family. For example, if the family has 20
#    members, the program generates n.mut.p x 20 mutants.
#    - fmax: argument for "LFENM". It is the maximun value for the forces that model the mutations.
#    - R0: the cut-off for the ANM ("Anisotropic Network Model") that represents the proteins.
#    - rotate: it can be "TRUE" or "FALSE". If it is "TRUE", r.p.2 is rotated in order to minimize RMSD with r.p.ref.
#    - core: it can be "TRUE" or "FALSE". If it is "TRUE", the program only considers the conserved core of
#    the alignment. If it is "FALSE", the program analyzes the whole alignment.
#    - heme: argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - analyze.family: It can be "TRUE" or "FALSE". If it is "TRUE" the program analyzes the family.
#    - generate.mutants: It can be "TRUE" or "FALSE". If it is "TRUE" the program generates new mutants.
#    - natural.selection: It can be "TRUE" or "FALSE". If it is "TRUE", the mutants are calculated considering natural
#    selection. If it is "FALSE", the mutants are calculated in a random manner.
#    - K.analysis: It can be "K" or "Keff". For "K" or "Keff", the analysis is based on normal modes of "K" or "Keff"
#    respectibly.
# Remove objects.
rm(list = ls())
# Load packages.
library(bio3d)
library(flux)
library(knitr)
library(markdown)
library(MASS)
library(rmarkdown)
library(seqinr)
# Data dir.
data.dir <- "DATA"
# Output dir.
out.dir <- "OUT"
# General parameters.
TOLERANCE = 1e-10
# Functions filenames.
AnalyzeExperimentalTheoretical.fname <- "FUNCTIONS/AnalyzeExperimentalTheoretical.R"
AnalyzeFamily.fname <- "FUNCTIONS/AnalyzeFamily.R"
AnalyzeAlignment.fname <- "FUNCTIONS/AnalyzeAlignment.R"
GenerateMutants.fname <- "FUNCTIONS/GenerateMutants.R"
ReadFasta.fname <- "FUNCTIONS/ReadFasta.R"
ReadCA.fname <- "FUNCTIONS/ReadCA.R"
ReadHeme.fname <- "FUNCTIONS/ReadHeme.R"
CalculateENMKeff.fname <- "FUNCTIONS/CalculateENMKeff.R"
CalculateENMK.fname <- "FUNCTIONS/CalculateENMK.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKij.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForce.R"
CalculateVariability.fname <- "FUNCTIONS/CalculateVariability.R"
# Source functions.
source(AnalyzeExperimentalTheoretical.fname)
source(AnalyzeFamily.fname)
source(AnalyzeAlignment.fname)
source(GenerateMutants.fname)
source(ReadFasta.fname)
source(ReadCA.fname)
source(ReadHeme.fname)
source(CalculateENMKeff.fname)
source(CalculateENMK.fname)
source(CalculateKij.fname)
source(CalculateForce.fname)
source(CalculateVariability.fname)
# Read input.
input.fname <- file.path("input_MainProgram.csv")
input <- read.csv(input.fname)
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
exp.chain.p.ref <- as.character(input$exp.chain.p.ref)[a]
mut.model = input$mut.model[a]
n.mut.p = input$n.mut.p[a]
fmax = input$fmax[a]
R0 = input$R0[a]
core <- input$core[a]
rotate <- input$rotate[a]
heme <- input$heme[a]
analyze.family <- input$analyze.familiy[a]
generate.mutants <- input$generate.mutants[a]
analyze.experimental.theoretical <- input$analyze.experimental.theoretical[a]
natural.selection <- input$natural.selection[a]
K.analysis <- input$K.analysis[a]
# Generate ids for output filenames.
mut.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", natural.selection, "_R0_", R0, sep = "")
analysis.fname.id <- paste(mut.fname.id, "_core_", core, "_K.analysis_", K.analysis, sep = "")
# Analyze the alignment of the family.
if (analyze.family == "TRUE") {
AnalyzeFamily(family,
p.ref,
data.dir,
out.dir)
}
# Generate mutants.
if (generate.mutants == "TRUE") {
GenerateMutants(family,
exp.chain.p.ref,
mut.model,
n.mut.p,
fmax,
R0,
heme,
natural.selection,
data.dir,
out.dir,
mut.fname.id,
TOLERANCE)
}
# Analyze measures of variability of experimental proteins and simulated mutants.
if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoretical(family,
exp.chain.p.ref,
n.mut.p,
R0,
core,
rotate,
heme,
natural.selection,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
TOLERANCE)
}
}
#  Generate a report.
#  rmarkdown::render('Report.Rmd',
#                    output_file = paste("report_", analysis.fname.id, ".html", sep = ''))
#}
aligned.p.1.index
aligned.p.1.index <- c(1,3,4,5)
aligned.p.1.index.3N = sort(c(aligned.p.1.index * 3, aligned.p.1.index * 3 - 2, aligned.p.1.index * 3 - 1))
aligned.p.1.index.3N
(c(aligned.p.1.index * 3, aligned.p.1.index * 3 - 2, aligned.p.1.index * 3 - 1))
matrix(aligned.p.1.index.3N,nrow=3)
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
mut.model = input$mut.model[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReport.Rmd',
output_file =  paste("report_", family,"_R0_", R0, "_K.analysis_", K.analysis, ".html", sep=''))
}
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
(as.vector(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1]))
* m.nsF.cF.theo.va[i, 1:nmodes1])
i.m.nsF.cF.theo.va[i, 1:nmodes1]
cor((as.vector(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1])) * m.nsF.cF.theo.va[i, 1:nmodes1]), i.m.nsF.cF.theo.va[i, 1:nmodes1], method = "pearson")
(as.vector(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1])) * m.nsF.cF.theo.va[i, 1:nmodes1])
dim(as.vector(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1])) * m.nsF.cF.theo.va[i, 1:nmodes1])
i.m.nsF.cF.theo.va[i, 1:nmodes1]
dim(i.m.nsF.cF.theo.va[i, 1:nmodes1])
cor((as.vector(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1])) * m.nsF.cF.theo.va[i, 1:nmodes1]), i.m.nsF.cF.theo.va[i, 1:nmodes1], method = "pearson")
i
cor((as.vector(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1])) * m.nsF.cF.theo.va[i, 1:nmodes1]), as.vector(i.m.nsF.cF.theo.va[i, 1:nmodes1]), method = "pearson")
i.m.nsF.cF.theo.va[i, 1:nmodes1]
m.nsF.cF.theo.va[i, 1:nmodes1]
1/m.nsF.cF.theo.va[i, 1:nmodes1]
cor((as.vector(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1])) * m.nsF.cF.theo.va[i, 1:nmodes1]), i.m.nsF.cF.theo.va[i, 1:nmodes1], method = "pearson")
as.numeric(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1]
)
)
m.nsF.cF.theo.Pn[i, 1:nmodes1]
cor((as.numeric(as.matrix(m.nsF.cF.theo.Pn[i, 1:nmodes1])) * m.nsF.cF.theo.va[i, 1:nmodes1]), as.numeric(i.m.nsF.cF.theo.va[i, 1:nmodes1]), method = "pearson")
m.nsF.cF.theo.va[i, 1:nmodes1])
as.numeric(m.nsF.cF.theo.Pn[i, 1:nmodes1] * m.nsF.cF.theo.va[i, 1:nmodes1])
as.numeric(i.m.nsF.cF.theo.va[i, 1:nmodes1])
nsF.cF.rho.t.1[i, ] <- cor(as.numeric(m.nsF.cF.theo.Pn[i, 1:nmodes1] * m.nsF.cF.theo.va[i, 1:nmodes1]), as.numeric(i.m.nsF.cF.theo.va[i, 1:nmodes1]), method = "pearson")
cor(as.numeric(m.nsF.cF.theo.Pn[i, 1:nmodes1] * m.nsF.cF.theo.va[i, 1:nmodes1]), as.numeric(i.m.nsF.cF.theo.va[i, 1:nmodes1]), method = "pearson")
layout(matrix(1:4, 2, 2, byrow = T))
plot(density(nsF.cF.rho.t.1), col = "blue", ylab = "Frecuencia", xlab = "rho", main = "Histograma rho 10 modos ns = F, c = F")
points(x = c(cF.rho.e.1), y = rep(0, n.exp), col = "red")
plot(density(nsT.cF.rho.t.1), col = "blue", ylab = "Frecuencia", xlab = "rho", main = "Histograma rho 10 modos ns = T, c = F")
points(x = c(cF.rho.e.1), y = rep(0, n.exp), col = "red")
plot(density(nsF.cT.rho.t.1), col = "blue", ylab = "Frecuencia", xlab = "rho", main = "Histograma rho 10 modos ns = F, c = T")
points(x = c(cT.rho.e.1), y = rep(0, n.exp), col = "red")
plot(density(nsT.cT.rho.t.1), col = "blue", ylab = "Frecuencia", xlab = "rho", main = "Histograma rho 10 modos ns = T, c = T")
points(x = c(cT.rho.e.1), y = rep(0, n.exp), col = "red")
# Calculate rho.
nsF.cF.rho.t.1 <- matrix(0, nrow = n.mut, ncol = 1)
nsF.cF.rho.t.3 <- matrix(0, nrow = n.mut, ncol = 1)
for (i in (1:n.mut)) {
nsF.cF.rho.t.1[i, ] <- cor(as.numeric(m.nsF.cF.theo.Pn[i, 1:nmodes1] * m.nsF.cF.theo.va[i, 1:nmodes1]), as.numeric(i.m.nsF.cF.theo.va[i, 1:nmodes1]), method = "pearson")
nsF.cF.rho.t.3[i, ] <- cor(as.numeric(m.nsF.cF.theo.Pn[i, 1:nmodes3] * m.nsF.cF.theo.va[i, 1:nmodes3]), as.numeric(i.m.nsF.cF.theo.va[i, 1:nmodes3]), method = "pearson")
}
nsT.cF.rho.t.1 <- matrix(0, nrow = n.mut, ncol = 1)
nsT.cF.rho.t.3 <- matrix(0, nrow = n.mut, ncol = 1)
for (i in (1:n.mut)) {
nsT.cF.rho.t.1[i, ] <- cor(as.numeric(m.nsT.cF.theo.Pn[i, 1:nmodes1] * m.nsT.cF.theo.va[i, 1:nmodes1]), as.numeric(i.m.nsT.cF.theo.va[i, 1:nmodes1]), method = "pearson")
nsT.cF.rho.t.3[i, ] <- cor(as.numeric(m.nsT.cF.theo.Pn[i, 1:nmodes3] * m.nsT.cF.theo.va[i, 1:nmodes3]), as.numeric(i.m.nsT.cF.theo.va[i, 1:nmodes3]), method = "pearson")
}
nsF.cT.rho.t.1 <- matrix(0, nrow = n.mut, ncol = 1)
nsF.cT.rho.t.3 <- matrix(0, nrow = n.mut, ncol = 1)
for (i in (1:n.mut)) {
nsF.cT.rho.t.1[i, ] <- cor(as.numeric(m.nsF.cT.theo.Pn[i, 1:nmodes1] * m.nsF.cT.theo.va[i, 1:nmodes1]), as.numeric(i.m.nsF.cT.theo.va[i, 1:nmodes1]), method = "pearson")
nsF.cT.rho.t.3[i, ] <- cor(as.numeric(m.nsF.cT.theo.Pn[i, 1:nmodes3] * m.nsF.cT.theo.va[i, 1:nmodes3]), as.numeric(i.m.nsF.cT.theo.va[i, 1:nmodes3]), method = "pearson")
}
nsT.cT.rho.t.1 <- matrix(0, nrow = n.mut, ncol = 1)
nsT.cT.rho.t.3 <- matrix(0, nrow = n.mut, ncol = 1)
for (i in (1:n.mut)) {
nsT.cT.rho.t.1[i, ] <- cor(as.numeric(m.nsT.cT.theo.Pn[i, 1:nmodes1] * m.nsT.cT.theo.va[i, 1:nmodes1]), as.numeric(i.m.nsT.cT.theo.va[i, 1:nmodes1]), method = "pearson")
nsT.cT.rho.t.3[i, ] <- cor(as.numeric(m.nsT.cT.theo.Pn[i, 1:nmodes3] * m.nsT.cT.theo.va[i, 1:nmodes3]), as.numeric(i.m.nsT.cT.theo.va[i, 1:nmodes3]), method = "pearson")
}
cF.rho.e.1 <- matrix(0, nrow = n.exp, ncol = 1)
cF.rho.e.3 <- matrix(0, nrow = n.exp, ncol = 1)
for (i in (1:n.exp)) {
cF.rho.e.1[i, ] <- cor(as.numeric(m.cF.exp.Pn[i, 1:nmodes1] * m.cF.exp.va[i, 1:nmodes1]), as.numeric(i.m.cF.exp.va[i, 1:nmodes1]), method = "pearson")
cF.rho.e.3[i, ] <- cor(as.numeric(m.cF.exp.Pn[i, 1:nmodes3] * m.cF.exp.va[i, 1:nmodes3]), as.numeric(i.m.cF.exp.va[i, 1:nmodes3]), method = "pearson")
}
cT.rho.e.1 <- matrix(0, nrow = n.exp, ncol = 1)
cT.rho.e.3 <- matrix(0, nrow = n.exp, ncol = 1)
for (i in (1:n.exp)) {
cT.rho.e.1[i, ] <- cor(as.numeric(m.cT.exp.Pn[i, 1:nmodes1] * m.cT.exp.va[i, 1:nmodes1]), as.numeric(i.m.cT.exp.va[i, 1:nmodes1]), method = "pearson")
cT.rho.e.3[i, ] <- cor(as.numeric(m.cT.exp.Pn[i, 1:nmodes3] * m.cT.exp.va[i, 1:nmodes3]), as.numeric(i.m.cT.exp.va[i, 1:nmodes3]), method = "pearson")
}
# Calculate auc.
nsF.cF.auc.t.1 <- matrix(0, nrow = n.mut, ncol = 1)
nsF.cF.auc.t.3 <- matrix(0, nrow = n.mut, ncol = 1)
for (i in (1:n.mut)) {
nsF.cF.auc.t.1[i, ] <- auc(seq(1:nmodes1), m.nsF.cF.theo.Qn[i,1:nmodes1])
nsF.cF.auc.t.3[i, ] <- auc(seq(1:nmodes3), m.nsF.cF.theo.Qn[i,1:nmodes3])
}
nsT.cF.auc.t.1 <- matrix(0, nrow = n.mut, ncol = 1)
nsT.cF.auc.t.3 <- matrix(0, nrow = n.mut, ncol = 1)
for (i in (1:n.mut)) {
nsT.cF.auc.t.1[i, ] <- auc(seq(1:nmodes1), m.nsT.cF.theo.Qn[i,1:nmodes1])
nsT.cF.auc.t.3[i, ] <- auc(seq(1:nmodes3), m.nsT.cF.theo.Qn[i,1:nmodes3])
}
cF.auc.e.1 <- matrix(0, nrow = n.exp, ncol = 1)
cF.auc.e.3 <- matrix(0, nrow = n.exp, ncol = 1)
for (i in (1:n.exp)) {
cF.auc.e.1[i, ] <- auc(seq(1:nmodes1), m.cF.exp.Qn[i, 1:nmodes1])
cF.auc.e.3[i, ] <- auc(seq(1:nmodes3), m.cF.exp.Qn[i, 1:nmodes3])
}
nsF.cT.auc.t.1 <- matrix(0, nrow = n.mut, ncol = 1)
nsF.cT.auc.t.3 <- matrix(0, nrow = n.mut, ncol = 1)
for (i in (1:n.mut)) {
nsF.cT.auc.t.1[i, ] <- auc(seq(1:nmodes1), m.nsF.cT.theo.Qn[i,1:nmodes1])
nsF.cT.auc.t.3[i, ] <- auc(seq(1:nmodes3), m.nsF.cT.theo.Qn[i,1:nmodes3])
}
nsT.cT.auc.t.1 <- matrix(0, nrow = n.mut, ncol = 1)
nsT.cT.auc.t.3 <- matrix(0, nrow = n.mut, ncol = 1)
for (i in (1:n.mut)) {
nsT.cT.auc.t.1[i, ] <- auc(seq(1:nmodes1), m.nsT.cT.theo.Qn[i,1:nmodes1])
nsT.cT.auc.t.3[i, ] <- auc(seq(1:nmodes3), m.nsT.cT.theo.Qn[i,1:nmodes3])
}
cT.auc.e.1 <- matrix(0, nrow = n.exp, ncol = 1)
cT.auc.e.3 <- matrix(0, nrow = n.exp, ncol = 1)
for (i in (1:n.exp)) {
cT.auc.e.1[i, ] <- auc(seq(1:nmodes1), m.cT.exp.Qn[i, 1:nmodes1])
cT.auc.e.3[i, ] <- auc(seq(1:nmodes3), m.cT.exp.Qn[i, 1:nmodes3])
}
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
mut.model = input$mut.model[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReport.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
mut.model = input$mut.model[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReport.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
warnings()
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
mut.model = input$mut.model[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReport.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
a
a
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
mut.model = input$mut.model[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReport.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
warnings()
