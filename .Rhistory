as.numeric(prob.accept.mut.beta.0.1)
(m.theo.Pn) * as.numeric(prob.accept.mut.beta.0.1)
mean.beta.0.1.theo.Pn = colSums((m.theo.Pn) * as.numeric(prob.accept.mut.beta.0.1))/ sum(prob.accept.mut.beta.0.1)
mean.beta.0.1.theo.Pn = colSums((m.theo.Pn) * as.numeric(prob.accept.mut.beta.0.1))/ sum(prob.accept.mut.beta.0.1)
mean.beta.0.5.theo.Pn = colSums(m.theo.Pn * as.numeric(aprob.accept.mut.beta.0.5))/ sum(prob.accept.mut.beta.0.5)
mean.beta.0.9.theo.Pn = colSums(m.theo.Pn * as.numeric(prob.accept.mut.beta.0.9))/ sum(prob.accept.mut.beta.0.9)
prob.accept.mut.beta.0.5 = prob.accept.mut.all.betas[2, ]
prob.accept.mut.beta.0.9 = prob.accept.mut.all.betas[3, ]
mean.beta.0.5.theo.Pn = colSums(m.theo.Pn * as.numeric(aprob.accept.mut.beta.0.5))/ sum(prob.accept.mut.beta.0.5)
mean.beta.0.9.theo.Pn = colSums(m.theo.Pn * as.numeric(prob.accept.mut.beta.0.9))/ sum(prob.accept.mut.beta.0.9)
mean.beta.0.5.theo.Pn = colSums(m.theo.Pn * as.numeric(prob.accept.mut.beta.0.5))/ sum(prob.accept.mut.beta.0.5)
mean.beta.0.theo.smooth.MSDi = ColMeans(m.theo.smooth.dr.squarei)
mean.beta.0.1.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * prob.accept.mut.beta.0.1)/ sum(prob.accept.mut.beta.0.1)
mean.beta.0.5.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * prob.accept.mut.beta.0.5)/ sum(prob.accept.mut.beta.0.5)
mean.beta.0.9.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * prob.accept.mut.beta.0.9)/ sum(prob.accept.mut.beta.0.9)
mean.beta.0.theo.smooth.MSDi = colMeans(m.theo.smooth.dr.squarei)
mean.beta.0.1.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * prob.accept.mut.beta.0.1)/ sum(prob.accept.mut.beta.0.1)
prob.accept.mut.beta.0.1
m.theo.smooth.dr.squarei
m.theo.smooth.dr.squarei
dataset.fname <- file.path(data.dir, paste(family, "_dataset.csv", sep = ""))
pdbs.fname <- file.path(data.dir, paste(family, "_coordinates.pdb", sep = ""))
m.n.aligned.fname <- file.path(out.dir, paste(family, "_out_m.n.aligned.csv", sep = ""))
m.aligned.p.ref.index.fname <- file.path(out.dir, paste(family, "_out_m.aligned.p.ref.index.csv", sep = ""))
m.aligned.p.2.index.fname <- file.path(out.dir, paste(family, "_out_m.aligned.p.2.index.csv", sep = ""))
m.not.aligned.p.ref.index.fname <- file.path(out.dir, paste(family, "_out_m.not.aligned.p.ref.index.csv", sep = ""))
m.not.aligned.p.2.index.fname <- file.path(out.dir, paste(family, "_out_m.not.aligned.p.2.index.csv", sep = ""))
# Theoretical data.
theo.r.p.ref.fname <- file.path(out.dir, paste(mut.fname.id, "_out_r.p.ref.csv", sep = ""))
m.r.mut.fname <- file.path(out.dir, paste(mut.fname.id, "_out_m.r.mut.csv", sep = ""))
# Read dataset.
dataset <- read.csv(dataset.fname)
pdbid.dataset <- as.character(dataset$pdbid)
chain <- as.character(dataset$chain)
n.prot = length(pdbid.dataset)
# Read pdb of exp.p.ref.
exp.pdb.p.ref = ReadCA(pdbs.fname, chain.p.ref)
exp.r.p.ref = exp.pdb.p.ref$xyz.calpha
n.aa.p.ref = exp.pdb.p.ref$n.sites
# Read indexes files.
m.n.aligned = read.csv(m.n.aligned.fname)
m.aligned.p.ref.index = read.csv(m.aligned.p.ref.index.fname)
m.aligned.p.2.index = read.csv(m.aligned.p.2.index.fname)
m.not.aligned.p.ref.index = read.csv(m.not.aligned.p.ref.index.fname)
m.not.aligned.p.2.index = read.csv(m.not.aligned.p.2.index.fname)
# Read theo.p.ref and the simulated mutants.
m.r.mut = read.csv(m.r.mut.fname)
theo.r.p.ref = read.csv(theo.r.p.ref.fname)$x
n.sites.p.ref = length(theo.r.p.ref)/3
# Create matrices to save measures of variability of each mutant.
m.exp.Pn = matrix(nrow = n.prot, ncol = 3 * n.sites.p.ref)
m.exp.va = matrix(nrow = n.prot, ncol = 3 * n.sites.p.ref)
m.exp.dr.squarei = matrix(nrow = n.prot, ncol = n.sites.p.ref)
m.exp.smooth.dr.squarei = matrix(nrow = n.prot, ncol = n.sites.p.ref)
m.exp.smooth.norm.dr.squarei = matrix(nrow = n.prot, ncol = n.sites.p.ref)
m.theo.Pn = matrix(nrow = n.prot * n.mut.p, ncol = 3 * n.sites.p.ref)
m.theo.va = matrix(nrow = n.prot * n.mut.p, ncol = 3 * n.sites.p.ref)
m.theo.dr.squarei = matrix(nrow = n.prot * n.mut.p, ncol = n.sites.p.ref)
m.theo.smooth.dr.squarei = matrix(nrow = n.prot * n.mut.p, ncol = n.sites.p.ref)
m.theo.smooth.norm.dr.squarei = matrix(nrow = n.prot * n.mut.p, ncol = n.sites.p.ref)
# EXPERIMENTAL:
# Start a loop to evaluate each protein of the family.
for (P in (1:n.prot)) {
print(P)
# Get aligned and not aligned indexes.
n.aligned = as.numeric(m.n.aligned[P, ])
aligned.p.ref.index = as.numeric(m.aligned.p.ref.index[P, !is.na(m.aligned.p.ref.index[P, ])])
aligned.p.2.index = as.numeric(m.aligned.p.2.index[P, !is.na(m.aligned.p.2.index[P, ])])
not.aligned.p.ref.index = as.numeric(m.not.aligned.p.ref.index[P, !is.na(m.not.aligned.p.ref.index[P, ])])
not.aligned.p.2.index = as.numeric(m.not.aligned.p.2.index[P, !is.na(m.not.aligned.p.2.index[P, ])])
# Read PDB of exp.p.2.
chain.p.2 <- chain[[P]]
exp.pdb.p.2 = ReadCA(pdbs.fname, chain.p.2)
exp.r.p.2 = exp.pdb.p.2$xyz.calpha
exp.n.aa.p.2 = exp.pdb.p.2$n.sites
# Calculate heme coordinates, add them to CA´s coordinates and calculate the number of sites and not aligned indexes.
if (heme == "TRUE") {
if (P == 1) {
exp.r.heme.p.ref = ReadHeme(pdbs.fname, chain.p.ref)
exp.r.p.ref = cbind(exp.r.p.ref, exp.r.heme.p.ref)
n.sites.p.ref = ncol(exp.r.p.ref)
}
exp.r.heme.p.2 = ReadHeme(pdbs.fname, chain.p.2)
exp.r.p.2 = cbind(exp.r.p.2, exp.r.heme.p.2)
exp.n.sites.p.2 = ncol(exp.r.p.2)
not.aligned.p.ref.index <- c(not.aligned.p.ref.index, t(seq((n.aa.p.ref + 1), n.sites.p.ref)))
not.aligned.p.2.index <- c(not.aligned.p.2.index, t(seq((exp.n.aa.p.2 + 1), exp.n.sites.p.2)))
}
# Calculate measures of variavility.
exp.variability = CalculateVariability(as.vector(exp.r.p.ref),
as.vector(exp.r.p.2),
aligned.p.ref.index,
aligned.p.2.index,
not.aligned.p.ref.index,
not.aligned.p.2.index,
R0,
rotate,
K.analysis,
TOLERANCE)
m.exp.va[P, 1:length(exp.variability$va)] = exp.variability$va
m.exp.Pn[P, 1:length(exp.variability$Pn)] = exp.variability$Pn
exp.dr.squarei = exp.variability$dr.squarei
for (i in (1:n.sites.p.ref)) {
m.exp.dr.squarei[P, i] = matrix(exp.dr.squarei[ aligned.p.ref.index == i], nrow = 1, ncol = 1)
}
# Calculate smooth dr.squarei.
kij = CalculateENMK(exp.r.p.ref, CalculateKij, R0, TOLERANCE)$kij
m.exp.dr.squarei.0 = m.exp.dr.squarei[P, ]
m.exp.dr.squarei.0[is.na(m.exp.dr.squarei.0)] = TOLERANCE
m.exp.smooth.dr.squarei[P, ] = (m.exp.dr.squarei[P, ] +  (kij %*%  m.exp.dr.squarei.0)) / (rowSums(kij[, !is.na(m.exp.dr.squarei[P, ])]) + 1)
m.exp.smooth.norm.dr.squarei[P, ] = m.exp.smooth.dr.squarei[P, ]/ mean(m.exp.smooth.dr.squarei[P, ], na.rm = T)
}
# THEORETICAL:
# Start a loop to analyze each mutant.
for (mut in (1:(n.prot * n.mut.p))) {
print(c(mut))
# Get theo.r.p.2.
theo.r.p.2 = m.r.mut[, mut]
# Calculate measures of variavility.
theo.variability = CalculateVariability(as.vector(theo.r.p.ref),
as.vector(theo.r.p.2),
seq(1, n.sites.p.ref),
seq(1, n.sites.p.ref),
c(),
c(),
R0,
rotate,
K.analysis,
TOLERANCE)
m.theo.va[mut, 1:length(theo.variability$va)] = theo.variability$va
m.theo.Pn[mut, 1:length(theo.variability$Pn)] = theo.variability$Pn
m.theo.dr.squarei[mut, 1:length(theo.variability$dr.squarei)] = theo.variability$dr.squarei
# Calculate smooth dr.squarei.
kij = CalculateENMK(matrix(theo.r.p.ref, nrow = 3), CalculateKij, R0, TOLERANCE)$kij
m.theo.dr.squarei.0 = m.theo.dr.squarei[P, ]
m.theo.dr.squarei.0[is.na(m.theo.dr.squarei.0)] = TOLERANCE
m.theo.smooth.dr.squarei[P, ] = (m.theo.dr.squarei[P, ] +  (kij %*%  m.theo.dr.squarei.0)) / (rowSums(kij[, !is.na(m.theo.dr.squarei[P, ])] + 1))
m.theo.smooth.norm.dr.squarei[P, ] = m.theo.smooth.dr.squarei[P, ]/ mean(m.theo.smooth.dr.squarei[P, ], na.rm = T)
}
m.theo.smooth.dr.squarei[P, ]
m.theo.smooth.norm.dr.squarei[P, ]
m.theo.smooth.norm.dr.squarei
P
m.exp.smooth.norm.dr.squarei
m.exp.smooth.dr.squarei
m.exp.smooth.norm.dr.squarei
m.theo.smooth.dr.squarei
m.theo.smooth.norm.dr.squarei
m.theo.dr.squarei
n.prot * n.mut.p
p
P
for (mut in (1:(n.prot * n.mut.p))) {
print(c(mut))
# Get theo.r.p.2.
theo.r.p.2 = m.r.mut[, mut]
# Calculate measures of variavility.
theo.variability = CalculateVariability(as.vector(theo.r.p.ref),
as.vector(theo.r.p.2),
seq(1, n.sites.p.ref),
seq(1, n.sites.p.ref),
c(),
c(),
R0,
rotate,
K.analysis,
TOLERANCE)
m.theo.va[mut, 1:length(theo.variability$va)] = theo.variability$va
m.theo.Pn[mut, 1:length(theo.variability$Pn)] = theo.variability$Pn
m.theo.dr.squarei[mut, 1:length(theo.variability$dr.squarei)] = theo.variability$dr.squarei
# Calculate smooth dr.squarei.
kij = CalculateENMK(matrix(theo.r.p.ref, nrow = 3), CalculateKij, R0, TOLERANCE)$kij
m.theo.dr.squarei.0 = m.theo.dr.squarei[P, ]
m.theo.dr.squarei.0[is.na(m.theo.dr.squarei.0)] = TOLERANCE
m.theo.smooth.dr.squarei[P, ] = (m.theo.dr.squarei[P, ] +  (kij %*%  m.theo.dr.squarei.0)) / (rowSums(kij[, !is.na(m.theo.dr.squarei[P, ])] + 1))
m.theo.smooth.norm.dr.squarei[P, ] = m.theo.smooth.dr.squarei[P, ]/ mean(m.theo.smooth.dr.squarei[P, ], na.rm = T)
}
mut
theo.r.p.2
theo.variability
theo.variability$va
theo.variability$Pn
theo.variability$dr.squarei
m.theo.dr.squarei.0
# FILENAMES.
# Experimental data.
dataset.fname <- file.path(data.dir, paste(family, "_dataset.csv", sep = ""))
pdbs.fname <- file.path(data.dir, paste(family, "_coordinates.pdb", sep = ""))
m.n.aligned.fname <- file.path(out.dir, paste(family, "_out_m.n.aligned.csv", sep = ""))
m.aligned.p.ref.index.fname <- file.path(out.dir, paste(family, "_out_m.aligned.p.ref.index.csv", sep = ""))
m.aligned.p.2.index.fname <- file.path(out.dir, paste(family, "_out_m.aligned.p.2.index.csv", sep = ""))
m.not.aligned.p.ref.index.fname <- file.path(out.dir, paste(family, "_out_m.not.aligned.p.ref.index.csv", sep = ""))
m.not.aligned.p.2.index.fname <- file.path(out.dir, paste(family, "_out_m.not.aligned.p.2.index.csv", sep = ""))
# Theoretical data.
theo.r.p.ref.fname <- file.path(out.dir, paste(mut.fname.id, "_out_r.p.ref.csv", sep = ""))
m.r.mut.fname <- file.path(out.dir, paste(mut.fname.id, "_out_m.r.mut.csv", sep = ""))
# Read dataset.
dataset <- read.csv(dataset.fname)
pdbid.dataset <- as.character(dataset$pdbid)
chain <- as.character(dataset$chain)
n.prot = length(pdbid.dataset)
# Read pdb of exp.p.ref.
exp.pdb.p.ref = ReadCA(pdbs.fname, chain.p.ref)
exp.r.p.ref = exp.pdb.p.ref$xyz.calpha
n.aa.p.ref = exp.pdb.p.ref$n.sites
# Read indexes files.
m.n.aligned = read.csv(m.n.aligned.fname)
m.aligned.p.ref.index = read.csv(m.aligned.p.ref.index.fname)
m.aligned.p.2.index = read.csv(m.aligned.p.2.index.fname)
m.not.aligned.p.ref.index = read.csv(m.not.aligned.p.ref.index.fname)
m.not.aligned.p.2.index = read.csv(m.not.aligned.p.2.index.fname)
# Read theo.p.ref and the simulated mutants.
m.r.mut = read.csv(m.r.mut.fname)
theo.r.p.ref = read.csv(theo.r.p.ref.fname)$x
n.sites.p.ref = length(theo.r.p.ref)/3
# Create matrices to save measures of variability of each mutant.
m.exp.Pn = matrix(nrow = n.prot, ncol = 3 * n.sites.p.ref)
m.exp.va = matrix(nrow = n.prot, ncol = 3 * n.sites.p.ref)
m.exp.dr.squarei = matrix(nrow = n.prot, ncol = n.sites.p.ref)
m.exp.smooth.dr.squarei = matrix(nrow = n.prot, ncol = n.sites.p.ref)
m.exp.smooth.norm.dr.squarei = matrix(nrow = n.prot, ncol = n.sites.p.ref)
m.theo.Pn = matrix(nrow = n.prot * n.mut.p, ncol = 3 * n.sites.p.ref)
m.theo.va = matrix(nrow = n.prot * n.mut.p, ncol = 3 * n.sites.p.ref)
m.theo.dr.squarei = matrix(nrow = n.prot * n.mut.p, ncol = n.sites.p.ref)
m.theo.smooth.dr.squarei = matrix(nrow = n.prot * n.mut.p, ncol = n.sites.p.ref)
m.theo.smooth.norm.dr.squarei = matrix(nrow = n.prot * n.mut.p, ncol = n.sites.p.ref)
# EXPERIMENTAL:
# Start a loop to evaluate each protein of the family.
for (P in (1:n.prot)) {
print(P)
# Get aligned and not aligned indexes.
n.aligned = as.numeric(m.n.aligned[P, ])
aligned.p.ref.index = as.numeric(m.aligned.p.ref.index[P, !is.na(m.aligned.p.ref.index[P, ])])
aligned.p.2.index = as.numeric(m.aligned.p.2.index[P, !is.na(m.aligned.p.2.index[P, ])])
not.aligned.p.ref.index = as.numeric(m.not.aligned.p.ref.index[P, !is.na(m.not.aligned.p.ref.index[P, ])])
not.aligned.p.2.index = as.numeric(m.not.aligned.p.2.index[P, !is.na(m.not.aligned.p.2.index[P, ])])
# Read PDB of exp.p.2.
chain.p.2 <- chain[[P]]
exp.pdb.p.2 = ReadCA(pdbs.fname, chain.p.2)
exp.r.p.2 = exp.pdb.p.2$xyz.calpha
exp.n.aa.p.2 = exp.pdb.p.2$n.sites
# Calculate heme coordinates, add them to CA´s coordinates and calculate the number of sites and not aligned indexes.
if (heme == "TRUE") {
if (P == 1) {
exp.r.heme.p.ref = ReadHeme(pdbs.fname, chain.p.ref)
exp.r.p.ref = cbind(exp.r.p.ref, exp.r.heme.p.ref)
n.sites.p.ref = ncol(exp.r.p.ref)
}
exp.r.heme.p.2 = ReadHeme(pdbs.fname, chain.p.2)
exp.r.p.2 = cbind(exp.r.p.2, exp.r.heme.p.2)
exp.n.sites.p.2 = ncol(exp.r.p.2)
not.aligned.p.ref.index <- c(not.aligned.p.ref.index, t(seq((n.aa.p.ref + 1), n.sites.p.ref)))
not.aligned.p.2.index <- c(not.aligned.p.2.index, t(seq((exp.n.aa.p.2 + 1), exp.n.sites.p.2)))
}
# Calculate measures of variavility.
exp.variability = CalculateVariability(as.vector(exp.r.p.ref),
as.vector(exp.r.p.2),
aligned.p.ref.index,
aligned.p.2.index,
not.aligned.p.ref.index,
not.aligned.p.2.index,
R0,
rotate,
K.analysis,
TOLERANCE)
m.exp.va[P, 1:length(exp.variability$va)] = exp.variability$va
m.exp.Pn[P, 1:length(exp.variability$Pn)] = exp.variability$Pn
exp.dr.squarei = exp.variability$dr.squarei
for (i in (1:n.sites.p.ref)) {
m.exp.dr.squarei[P, i] = matrix(exp.dr.squarei[ aligned.p.ref.index == i], nrow = 1, ncol = 1)
}
# Calculate smooth dr.squarei.
kij = CalculateENMK(exp.r.p.ref, CalculateKij, R0, TOLERANCE)$kij
m.exp.dr.squarei.0 = m.exp.dr.squarei[P, ]
m.exp.dr.squarei.0[is.na(m.exp.dr.squarei.0)] = TOLERANCE
m.exp.smooth.dr.squarei[P, ] = (m.exp.dr.squarei[P, ] +  (kij %*%  m.exp.dr.squarei.0)) / (rowSums(kij[, !is.na(m.exp.dr.squarei[P, ])]) + 1)
m.exp.smooth.norm.dr.squarei[P, ] = m.exp.smooth.dr.squarei[P, ]/ mean(m.exp.smooth.dr.squarei[P, ], na.rm = T)
}
# THEORETICAL:
# Start a loop to analyze each mutant.
for (mut in (1:(n.prot * n.mut.p))) {
print(c(mut))
# Get theo.r.p.2.
theo.r.p.2 = m.r.mut[, mut]
# Calculate measures of variavility.
theo.variability = CalculateVariability(as.vector(theo.r.p.ref),
as.vector(theo.r.p.2),
seq(1, n.sites.p.ref),
seq(1, n.sites.p.ref),
c(),
c(),
R0,
rotate,
K.analysis,
TOLERANCE)
m.theo.va[mut, 1:length(theo.variability$va)] = theo.variability$va
m.theo.Pn[mut, 1:length(theo.variability$Pn)] = theo.variability$Pn
m.theo.dr.squarei[mut, 1:length(theo.variability$dr.squarei)] = theo.variability$dr.squarei
# Calculate smooth dr.squarei.
kij = CalculateENMK(matrix(theo.r.p.ref, nrow = 3), CalculateKij, R0, TOLERANCE)$kij
m.theo.dr.squarei.0 = m.theo.dr.squarei[P, ]
m.theo.dr.squarei.0[is.na(m.theo.dr.squarei.0)] = TOLERANCE
m.theo.smooth.dr.squarei[mut, ] = (m.theo.dr.squarei[P, ] +  (kij %*%  m.theo.dr.squarei.0)) / (rowSums(kij[, !is.na(m.theo.dr.squarei[P, ])] + 1))
m.theo.smooth.norm.dr.squarei[mut, ] = m.theo.smooth.dr.squarei[P, ]/ mean(m.theo.smooth.dr.squarei[P, ], na.rm = T)
}
# Create files to save the data.
write.csv(m.exp.va, file = file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.va.csv", sep = "")), row.names = FALSE)
write.csv(m.exp.Pn, file = file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.Pn.csv", sep = "")), row.names = FALSE)
write.csv(m.exp.smooth.norm.dr.squarei, file = file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.norm.dr.squarei.csv", sep = "")), row.names = FALSE)
write.csv(m.theo.va, file = file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.va.csv", sep = "")), row.names = FALSE)
write.csv(m.theo.Pn, file = file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.Pn.csv", sep = "")), row.names = FALSE)
write.csv(m.theo.smooth.norm.dr.squarei, file = file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.norm.dr.squarei.csv", sep = "")), row.names = FALSE)
```{r}
# Source functions.
source("FUNCTIONS/CalculateGroupsMeansQuantiles.R")
# Read files and calculate measures.
data.dir <- "DATA"
out.dir <- "OUT"
# Family.
pdbid <- read.csv(file.path(data.dir, paste(family, "_dataset.csv", sep = "")))$pdbid
n.exp = length(pdbid)
n.sites.p.1 = read.csv(file.path(out.dir, paste(family, "_out_m.n.sites.p.ref.csv", sep = "")))$V1[1]
m.n.sites.p.2 = read.csv(file.path(out.dir, paste(family, "_out_m.n.sites.p.2.csv", sep = "")))$V1
m.n.aligned = read.csv(file.path(out.dir, paste(family, "_out_m.n.aligned.csv", sep = "")))$V1
identity = read.csv(file.path(out.dir, paste(family, "_out_m.identity.csv", sep = "")))$V1
# Read experimental.
analysis.fname.id <- paste(family, "_R0_", R0, "_K.analysis_", K.analysis, sep = "")
m.exp.Pn = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.Pn.csv", sep = "")))[, 1:100]
mean.exp.Pn = colMeans(m.exp.Pn)
exp.Pn.quantile1 = matrix(0, ncol = ncol(m.exp.Pn), nrow = 1)
exp.Pn.quantile2 = matrix(0, ncol = ncol(m.exp.Pn), nrow = 1)
for (i in (1:ncol(m.exp.Pn))){
exp.Pn.quantiles = as.vector(quantile((m.exp.Pn[, i]), probs = c(0.05, 0.95)))
exp.Pn.quantile1[1, i] = exp.Pn.quantiles[1]
exp.Pn.quantile2[1, i] = exp.Pn.quantiles[2]
}
m.exp.smooth.norm.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.norm.dr.squarei.csv", sep = "")))
exp.smooth.norm.MSDi = colMeans(m.exp.smooth.norm.dr.squarei, na.rm = T )
### Theoretical ###
mut.fname.id <- paste(family, "_R0_", R0, sep = "")
m.theo.Pn = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.Pn.csv", sep = "")))[, 1:100]
m.theo.smooth.norm.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.norm.dr.squarei.csv", sep = "")))
prob.accept.mut.all.betas = read.csv(file.path(out.dir, paste(mut.fname.id, "_out_prob.accept.mut.all.betas.csv", sep = "")))
n.mut = nrow(m.theo.Pn)
prob.accept.mut.beta.0.1 = prob.accept.mut.all.betas[1, ]
prob.accept.mut.beta.0.5 = prob.accept.mut.all.betas[2, ]
prob.accept.mut.beta.0.9 = prob.accept.mut.all.betas[3, ]
mean.beta.0.theo.Pn = ColMeans(m.theo.Pn)
mean.beta.0.1.theo.Pn = colSums((m.theo.Pn) * as.numeric(prob.accept.mut.beta.0.1))/ sum(prob.accept.mut.beta.0.1)
mean.beta.0.5.theo.Pn = colSums(m.theo.Pn * as.numeric(prob.accept.mut.beta.0.5))/ sum(prob.accept.mut.beta.0.5)
mean.beta.0.9.theo.Pn = colSums(m.theo.Pn * as.numeric(prob.accept.mut.beta.0.9))/ sum(prob.accept.mut.beta.0.9)
mean.beta.0.theo.smooth.MSDi = colMeans(m.theo.smooth.dr.squarei)
mean.beta.0.1.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.1))/ sum(prob.accept.mut.beta.0.1)
mean.beta.0.5.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.5))/ sum(prob.accept.mut.beta.0.5)
mean.beta.0.9.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.9))/ sum(prob.accept.mut.beta.0.9)
fit.beta.0 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.theo.smooth.MSDi )
MSDi.fit.beta.0 = fitted.values(fit.beta.0)
R2.beta.0 = cor(exp.smooth.MSDi[!is.na(exp.smooth.MSDi)], MSDi.fit.beta.0) ^ 2
MSE.beta.0 = mean((MSDi.fit.beta.0 - exp.smooth.MSDi[!is.na(exp.smooth.MSDi)]) ^ 2)
fit.beta.0.1 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.1.theo.smooth.MSDi )
MSDi.fit.beta.0.1 = fitted.values(fit.beta.0.1)
R2.beta.0.1 = cor(exp.smooth.MSDi[!is.na(exp.smooth.MSDi)], MSDi.fit.beta.0.1) ^ 2
MSE.beta.0.1 = mean((MSDi.fit.beta.0.1 - exp.smooth.MSDi[!is.na(exp.smooth.MSDi)]) ^ 2)
fit.beta.0.5 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.5.theo.smooth.MSDi )
MSDi.fit.beta.0.5 = fitted.values(fit.beta.0.5)
R2.beta.0.5 = cor(exp.smooth.MSDi[!is.na(exp.smooth.MSDi)], MSDi.fit.beta.0.5) ^ 2
MSE.beta.0.5 = mean((MSDi.fit.beta.0.5 - exp.smooth.MSDi[!is.na(exp.smooth.MSDi)]) ^ 2)
fit.beta.0.9 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.9.theo.smooth.MSDi )
MSDi.fit.beta.0.9 = fitted.values(fit.beta.0.9)
R2.beta.0.9 = cor(exp.smooth.MSDi[!is.na(exp.smooth.MSDi)], MSDi.fit.beta.0.9) ^ 2
MSE.beta.0.9 = mean((MSDi.fit.beta.0.9 - exp.smooth.MSDi[!is.na(exp.smooth.MSDi)]) ^ 2)
exp.smooth.norm.MSDi
mean.beta.0.theo.smooth.MSDi
m.theo.smooth.dr.squarei
mean.beta.0.theo.smooth.MSDi = colMeans(m.theo.smooth.dr.squarei, na.rm = T)
mean.beta.0.theo.smooth.MSDi
mean.beta.0.1.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.1))/ sum(prob.accept.mut.beta.0.1)
mean.beta.0.1.theo.smooth.MSDi
prob.accept.mut.beta.0.1
colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.1))
m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.1
)
mean.beta.0.1.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.1), na.rm = T)/ sum(prob.accept.mut.beta.0.1, na.rm = T )
mean.beta.0.1.theo.smooth.MSDi
mean.beta.0.theo.smooth.MSDi = colMeans(m.theo.smooth.dr.squarei, na.rm = T)
mean.beta.0.1.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.1), na.rm = T)/ sum(prob.accept.mut.beta.0.1, na.rm = T )
mean.beta.0.5.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.5), na.rm = T))/ sum(prob.accept.mut.beta.0.5, na.rm = T)
mean.beta.0.9.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.9), na.rm = T))/ sum(prob.accept.mut.beta.0.9, na.rm = T)
mean.beta.0.5.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.5), na.rm = T)/ sum(prob.accept.mut.beta.0.5, na.rm = T)
mean.beta.0.9.theo.smooth.MSDi = colSums(m.theo.smooth.dr.squarei * as.numeric(prob.accept.mut.beta.0.9), na.rm = T)/ sum(prob.accept.mut.beta.0.9, na.rm = T)
mean.beta.0.5.theo.smooth.MSDi
mean.beta.0.9.theo.smooth.MSDi
fit.beta.0 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.theo.smooth.MSDi )
MSDi.fit.beta.0 = fitted.values(fit.beta.0)
R2.beta.0 = cor(exp.smooth.MSDi[!is.na(exp.smooth.MSDi)], MSDi.fit.beta.0) ^ 2
MSE.beta.0 = mean((MSDi.fit.beta.0 - exp.smooth.MSDi[!is.na(exp.smooth.MSDi)]) ^ 2)
MSDi.fit.beta.0 = fitted.values(fit.beta.0)
R2.beta.0 = cor(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], MSDi.fit.beta.0) ^ 2
MSE.beta.0 = mean((MSDi.fit.beta.0 - exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]) ^ 2)
fit.beta.0.1 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.1.theo.smooth.MSDi )
MSDi.fit.beta.0.1 = fitted.values(fit.beta.0.1)
R2.beta.0.1 = cor(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], MSDi.fit.beta.0.1) ^ 2
MSE.beta.0.1 = mean((MSDi.fit.beta.0.1 - exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]) ^ 2)
fit.beta.0.5 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.5.theo.smooth.MSDi )
MSDi.fit.beta.0.5 = fitted.values(fit.beta.0.5)
R2.beta.0.5 = cor(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], MSDi.fit.beta.0.5) ^ 2
MSE.beta.0.5 = mean((MSDi.fit.beta.0.5 - exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]) ^ 2)
fit.beta.0.9 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.9.theo.smooth.MSDi )
MSDi.fit.beta.0.9 = fitted.values(fit.beta.0.9)
R2.beta.0.9 = cor(exp.norm.smooth.MSDi[!is.na(exp.smooth.norm.MSDi)], MSDi.fit.beta.0.9) ^ 2
MSE.beta.0.9 = mean((MSDi.fit.beta.0.9 - exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]) ^ 2)
plot(MSDi.fit.beta.0, type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0",  ylim = c(0, 0.14))
fit.beta.0.9 = lm(exp.smooth.norm.MSDi ~ mean.beta.0.9.theo.smooth.MSDi )
MSDi.fit.beta.0.9 = fitted.values(fit.beta.0.9)
R2.beta.0.9 = cor(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], MSDi.fit.beta.0.9) ^ 2
MSE.beta.0.9 = mean((MSDi.fit.beta.0.9 - exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]) ^ 2)
plot(MSDi.fit.beta.0, type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0",  ylim = c(0, 0.14))
MSDi.fit.beta.0
plot(as.numeric(MSDi.fit.beta.0), type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0",  ylim = c(0, 0.14))
as.numeric(MSDi.fit.beta.0)
plot(as.numeric(MSDi.fit.beta.0), type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0"))
plot(as.numeric(MSDi.fit.beta.0), type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0")
lines(MSDi.fit.beta.0.1, type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0.1", col = "red")
lines(MSDi.fit.beta.0.5, type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0.5", col = "blue")
lines(MSDi.fir.beta.0.9, type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0.9", col = "green")
lines(MSDi.fit.beta.0.9, type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0.9", col = "green")
points(exp.smooth.MSDi[!is.na(exp.smooth.MSDi)], type = "l", xlab = "site", ylab = "Experimental")
points(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], type = "l", xlab = "site", ylab = "Experimental")
plot(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], type = "l", xlab = "site", ylab = "Experimental")
lines(as.numeric(MSDi.fit.beta.0), type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0", col = "red")
MSDi.fit.beta.0.1
plot(MSDi.fit.beta.0.1, MSDi.fit.beta.0.9)
prob.accept.mut.beta.0.1
prob.accept.mut.beta.0.5
prob.accept.mut.beta.0.9
cor(prob.accept.mut.beta.0.9, prob.accept.mut.beta.0.1)
cor(as.numeric(prob.accept.mut.beta.0.9), as.numeric(prob.accept.mut.beta.0.1))
cor(as.numeric(prob.accept.mut.beta.0.5), as.numeric(prob.accept.mut.beta.0.1))
cor(as.numeric(prob.accept.mut.beta.0.5), as.numeric(prob.accept.mut.beta.0.9))
MSDi.fit.beta.0
prob.accept.mut.beta.0.1
c(1,2,4)
exp(-2*c)
v=c(1,2,4)
exp(-2*v)
exp(-4*v)
v3=exp(-4*v)
v2=exp(-2*v)
cor(v2,v3)
cor(v2,v)
plot(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], type = "l", xlab = "site", ylab = "Experimental")
lines(as.numeric(MSDi.fit.beta.0), type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0", col = "red")
lines(MSDi.fit.beta.0.1, type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0.1", col = "red")
lines(as.numeric(MSDi.fit.beta.0), type = "l", xlab = "site", ylab = "Theoretical MSDi BETA = 0", col = "red")
cor(as.numeric(prob.accept.mut.beta.0), as.numeric(prob.accept.mut.beta.0.9))
cor(as.numeric(MSDi.fit.beta.0), as.numeric(MSDi.fit.beta.0.9))
cor(as.numeric(MSDi.fit.beta.0), as.numeric(MSDi.fit.beta.0.5))
cor(as.numeric(MSDi.fit.beta.0), as.numeric(MSDi.fit.beta.0.1))
exp.smooth.norm.MSDi
mean.beta.0.theo.smooth.MSDi
mean.beta.0.1.theo.smooth.MSDi
MSDi.fit.beta.0
MSDi.fit.beta.0.1
runif(1,0,1)
paccept = 0.1
paccept = 0.8
runif(100,0,1)
mean(runif(100,0,1))
(runif(100,0,1))>0.8
as.numeric((runif(100,0,1))>0.8)
sum(as.numeric((runif(100,0,1))>0.8))
sum(as.numeric((runif(1000,0,1))>0.8))
sum(as.numeric((runif(10000,0,1))>0.8))*100/10000
sum(as.numeric((runif(10000,0,1))<0.8))*100/10000
exp0.8
{}
}
exp(-0.8exp
)
exp(-0.8)
exp(-0)
exp(-0.5*0.8)
exp(-0.9*0.8)
exp(-1*0.8)
exp(0*0.8)
exp(0.1*0.8)
exp(0.5*0.8)
exp(0.9*0.8)
exp(0*0.8)
exp(-0.1*0.8)
exp(-0.5*0.8)
exp(-0.9*0.8)
exp(-1*0.8)
m=2
n=10
exp(-m)
exp(-n)
exp(-0.5*m)
exp(-0.5*m)/exp(-m)
exp(-0.5*n)/exp(-n)
exp(-0.5*n)
exp(-0.5*n)/exp(-n)
exp(-0.5*n)
20
n= 20
m = 30
exp(-20)
exp(-30)
exp(-30/2)
exp(-20/2)
exp(-0.5*20/2)
exp(-0.05*20/2)
