for (beta in all.betas)  {
### Experimental ###
analysis.fname.id <- paste(family, "_R0_", R0, "_beta_", beta, "_K.analysis_", K.analysis, sep = "")
m.exp.Pn = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.Pn.csv", sep = "")))[, 1:100]
mean.exp.Pn = colMeans(m.exp.Pn)
n.prot = nrow(m.exp.Pn)
exp.Pn.quantile1 = matrix(ncol = ncol(m.exp.Pn), nrow = 1)
exp.Pn.quantile2 = matrix(ncol = ncol(m.exp.Pn), nrow = 1)
for (i in (1:ncol(m.exp.Pn))) {
exp.Pn.quantiles = as.vector(quantile((m.exp.Pn[, i]), probs = c(0.05, 0.95)))
exp.Pn.quantile1[1, i] = exp.Pn.quantiles[1]
exp.Pn.quantile2[1, i] = exp.Pn.quantiles[2]
}
m.mean.exp.Pn[as.vector(all.betas == beta), 1:length(mean.exp.Pn)] = mean.exp.Pn
m.exp.Pn.quantile1[as.vector(all.betas == beta), 1:length(exp.Pn.quantile1)] = exp.Pn.quantile1
m.exp.Pn.quantile2[as.vector(all.betas == beta), 1:length(exp.Pn.quantile2)] = exp.Pn.quantile2
m.exp.smooth.norm.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.norm.dr.squarei.csv", sep = "")))
exp.smooth.norm.MSDi = colMeans(m.exp.smooth.norm.dr.squarei, na.rm = T )
### Theoretical ###
m.theo.Pn = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.Pn.csv", sep = "")))[, 1:100]
m.theo.smooth.norm.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.norm.dr.squarei.csv", sep = "")))
theo.smooth.norm.MSDi = colMeans(m.theo.smooth.norm.dr.squarei, na.rm = T )
n.mut = nrow(m.theo.Pn)
fit = lm(exp.smooth.norm.MSDi ~ theo.smooth.norm.MSDi )
MSDi.fit = fitted.values(fit)
MSDi.R2 = cor(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], MSDi.fit) ^ 2
MSDi.MSE = mean((MSDi.fit - exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]) ^ 2)
exp.smooth.norm.MSDi = exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]
m.MSDi.fit[as.vector(all.betas == beta), ] = MSDi.fit
m.MSDi.R2[as.vector(all.betas == beta), ] = MSDi.R2
m.MSDi.MSE[as.vector(all.betas == beta), ] = MSDi.MSE
m.exp.MSDi[as.vector(all.betas == beta), ] = exp.smooth.norm.MSDi
### Pn ###
# Re-ordenate Pn.
m.theo.index = matrix(ncol = 1, nrow = n.mut)
for (P in (1:n.prot)) {
for (mut in (1:n.mut.p)) {
m.theo.index[(P - 1) * n.mut.p + mut, ] = ((mut - 1) * 10 + P)
}
}
m.theo.Pn = m.theo.Pn[as.vector(m.theo.index), ]
# Calculate groups, means and quantiles.
theo.Pn.group = CalculateGroupsMeansQuantiles(m.theo.Pn, n.mut.p, n.prot)
mean.theo.Pn.group = theo.Pn.group$mean.mean.group
theo.Pn.group.quantile1 = theo.Pn.group$mean.quantile1.group
theo.Pn.group.quantile2 = theo.Pn.group$mean.quantile2.group
theo.Pn.quantile1.mean = theo.Pn.group$quantile1.mean
theo.Pn.quantile2.mean = theo.Pn.group$quantile2.mean
m.mean.theo.Pn.group[as.vector(all.betas == beta), 1:length(mean.theo.Pn.group)] = mean.theo.Pn.group
m.theo.Pn.group.quantile1[as.vector(all.betas == beta), 1:length(theo.Pn.group.quantile1)] = theo.Pn.group.quantile1
m.theo.Pn.group.quantile2[as.vector(all.betas == beta), 1:length(theo.Pn.group.quantile2)] = theo.Pn.group.quantile2
m.theo.Pn.quantile1.mean[as.vector(all.betas == beta), 1:length(theo.Pn.quantile1.mean)] = theo.Pn.quantile1.mean
m.theo.Pn.quantile2.mean[as.vector(all.betas == beta), 1:length(theo.Pn.quantile2.mean)] = theo.Pn.quantile2.mean
}
plot(m.mean.theo.Pn.group[1, 1:100],
main = "Pn promedio",
xlab = "nmodo",
ylab = "Pn",
ylim = c(0, max(c(m.theo.Pn.group.quantile2[1, ], m.mean.exp.Pn[1, ]))))
m.mean.exp.Pn
plot(m.mean.theo.Pn.group[1, 1:100],
main = "Pn promedio",
xlab = "nmodo",
ylab = "Pn",
ylim = c(0, max(c(m.theo.Pn.group.quantile2[1, 1:100], m.mean.exp.Pn[1, 1:100]))))
lines(m.theo.Pn.group.quantile1[1, ])
lines(m.theo.Pn.group.quantile2[1, ])
points(m.mean.exp[1, ].Pn, col = "red")
points(m.mean.exp.Pn[1, ], col = "red")
lines(as.vector(m.exp.Pn.quantile1[1, ]), col = "red")
lines(as.vector(m.exp.Pn.quantile2[1, ]), col = "red")
plot(m.mean.theo.Pn.group[1, ],
main = "Pn promedio",
xlab = "nmodo",
ylab = "Pn",
ylim = c(0, max(c(m.theo.Pn.group.quantile2[1, ], m.mean.exp.Pn[1, ]))))
lines(as.vector(m.theo.Pn.quantile1.mean[1, ]))
lines(as.vector(m.theo.Pn.quantile2.mean[1, ]))
points(mean.exp.Pn, col = "red")
plot(m.mean.theo.Pn.group[1, 1:100],
main = "Pn promedio",
xlab = "nmodo",
ylab = "Pn",
ylim = c(0, max(c(m.theo.Pn.group.quantile2[1, 1:100], m.mean.exp.Pn[1, 1:100]))))
lines(as.vector(m.theo.Pn.quantile1.mean[1, ]))
lines(as.vector(m.theo.Pn.quantile2.mean[1, ]))
points(mean.exp.Pn, col = "red")
layout(matrix(1:4, 2, 2, byrow = T))
plot(m.mean.theo.Pn.group[1, 1:100],
main = "Pn strong selection",
xlab = "nmodo",
ylab = "Pn",
ylim = c(0, max(c(m.theo.Pn.group.quantile2[1, 1:100], m.mean.exp.Pn[1, 1:100]))))
lines(as.vector(m.theo.Pn.quantile1.mean[1, ]))
lines(as.vector(m.theo.Pn.quantile2.mean[1, ]))
points(m.mean.exp.Pn[1, ], col = "red")
plot(m.mean.theo.Pn.group[2, 1:100],
main = "Pn medium selection",
xlab = "nmodo",
ylab = "Pn",
ylim = c(0, max(c(m.theo.Pn.group.quantile2[2, 1:100], m.mean.exp.Pn[2, 1:100]))))
lines(as.vector(m.theo.Pn.quantile1.mean[2, ]))
lines(as.vector(m.theo.Pn.quantile2.mean[2, ]))
points(m.mean.exp.Pn[2, ], col = "red")
plot(m.mean.theo.Pn.group[3, 1:100],
main = "Pn weak selection",
xlab = "nmodo",
ylab = "Pn",
ylim = c(0, max(c(m.theo.Pn.group.quantile2[3, 1:100], m.mean.exp.Pn[3, 1:100]))))
lines(as.vector(m.theo.Pn.quantile1.mean[3, ]))
lines(as.vector(m.theo.Pn.quantile2.mean[3, ]))
points(m.mean.exp.Pn[3, ], col = "red")
plot(m.mean.theo.Pn.group[4, 1:100],
main = "Pn no selection",
xlab = "nmodo",
ylab = "Pn",
ylim = c(0, max(c(m.theo.Pn.group.quantile2[4, 1:100], m.mean.exp.Pn[4, 1:100]))))
lines(as.vector(m.theo.Pn.quantile1.mean[4, ]))
lines(as.vector(m.theo.Pn.quantile2.mean[4, ]))
points(m.mean.exp.Pn[4, ], col = "red")
mean.exp.Pn
mean.theo.Pn.group
fit = lm(mean.exp.Pn ~  mean.theo.Pn.group)
Pn.fit = fitted.values(fit)
Pn.R2 = cor(mean.exp.Pn, Pn.fit) ^ 2
Pn.MSE = mean((Pn.fit - mean.exp.Pn) ^ 2)
m.Pn.fit = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.exp.Pn = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.Pn.R2 = matrix(nrow = 4, ncol = 1)
m.Pn.MSE = matrix(nrow = 4, ncol = 1)
Pn.fit = lm(mean.exp.Pn ~  mean.theo.Pn.group)
Pn.fit = fitted.values(Pn.fit)
Pn.R2 = cor(mean.exp.Pn, Pn.fit) ^ 2
Pn.MSE = mean((Pn.fit - mean.exp.Pn) ^ 2)
m.Pn.fit[as.vector(all.betas == beta), ] = Pn.fit
m.Pn.R2[as.vector(all.betas == beta), ] = Pn.R2
m.Pn.MSE[as.vector(all.betas == beta), ] = Pn.MSE
m.mean.exp.Pn[as.vector(all.betas == beta), ] = mean.exp.Pn
m.mean.exp.Pn[as.vector(all.betas == beta), 1:(length(mean.Pn))] = mean.exp.Pn
m.mean.exp.Pn[as.vector(all.betas == beta), 1:(length(mean.exp.Pn))] = mean.exp.Pn
# Source functions.
source("FUNCTIONS/CalculateGroupsMeansQuantiles.R")
# Set directories.
data.dir <- "DATA"
out.dir <- "OUT"
# p.ref.
n.sites.p.ref = read.csv(file.path(out.dir, paste(family, "_out_m.n.sites.p.ref.csv", sep = "")))$V1[1]
# Create matrices to save data.
m.MSDi.fit = matrix(nrow = 4, ncol = n.sites.p.ref)
m.exp.MSDi = matrix(nrow = 4, ncol = n.sites.p.ref)
m.MSDi.R2 = matrix(nrow = 4, ncol = 1)
m.MSDi.MSE = matrix(nrow = 4, ncol = 1)
m.Pn.fit = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.exp.Pn = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.Pn.R2 = matrix(nrow = 4, ncol = 1)
m.Pn.MSE = matrix(nrow = 4, ncol = 1)
m.mean.theo.Pn.group = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.theo.Pn.group.quantile1 = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.theo.Pn.group.quantile2 = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.theo.Pn.quantile1.mean = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.theo.Pn.quantile2.mean = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.mean.exp.Pn = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.exp.Pn.quantile1 = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.exp.Pn.quantile2 = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
# Read betas.
betas.fname.id <- paste(family, "_", p.ref, "_R0_", R0, sep = "")
all.betas <- read.csv(file.path(out.dir, paste(betas.fname.id, "_out_all.betas.csv", sep = "")))
# Start a loop for each beta.
for (beta in all.betas)  {
### Experimental ###
analysis.fname.id <- paste(family, "_R0_", R0, "_beta_", beta, "_K.analysis_", K.analysis, sep = "")
m.exp.Pn = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.Pn.csv", sep = "")))[, 1:100]
mean.exp.Pn = colMeans(m.exp.Pn)
n.prot = nrow(m.exp.Pn)
exp.Pn.quantile1 = matrix(ncol = ncol(m.exp.Pn), nrow = 1)
exp.Pn.quantile2 = matrix(ncol = ncol(m.exp.Pn), nrow = 1)
for (i in (1:ncol(m.exp.Pn))) {
exp.Pn.quantiles = as.vector(quantile((m.exp.Pn[, i]), probs = c(0.05, 0.95)))
exp.Pn.quantile1[1, i] = exp.Pn.quantiles[1]
exp.Pn.quantile2[1, i] = exp.Pn.quantiles[2]
}
m.mean.exp.Pn[as.vector(all.betas == beta), 1:length(mean.exp.Pn)] = mean.exp.Pn
m.exp.Pn.quantile1[as.vector(all.betas == beta), 1:length(exp.Pn.quantile1)] = exp.Pn.quantile1
m.exp.Pn.quantile2[as.vector(all.betas == beta), 1:length(exp.Pn.quantile2)] = exp.Pn.quantile2
m.exp.smooth.norm.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.norm.dr.squarei.csv", sep = "")))
exp.smooth.norm.MSDi = colMeans(m.exp.smooth.norm.dr.squarei, na.rm = T )
### Theoretical ###
m.theo.Pn = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.Pn.csv", sep = "")))[, 1:100]
m.theo.smooth.norm.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.norm.dr.squarei.csv", sep = "")))
theo.smooth.norm.MSDi = colMeans(m.theo.smooth.norm.dr.squarei, na.rm = T )
n.mut = nrow(m.theo.Pn)
fit = lm(exp.smooth.norm.MSDi ~ theo.smooth.norm.MSDi )
MSDi.fit = fitted.values(fit)
MSDi.R2 = cor(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], MSDi.fit) ^ 2
MSDi.MSE = mean((MSDi.fit - exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]) ^ 2)
exp.smooth.norm.MSDi = exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]
m.MSDi.fit[as.vector(all.betas == beta), ] = MSDi.fit
m.MSDi.R2[as.vector(all.betas == beta), ] = MSDi.R2
m.MSDi.MSE[as.vector(all.betas == beta), ] = MSDi.MSE
m.exp.MSDi[as.vector(all.betas == beta), ] = exp.smooth.norm.MSDi
### Pn ###
# Re-ordenate Pn.
m.theo.index = matrix(ncol = 1, nrow = n.mut)
for (P in (1:n.prot)) {
for (mut in (1:n.mut.p)) {
m.theo.index[(P - 1) * n.mut.p + mut, ] = ((mut - 1) * 10 + P)
}
}
m.theo.Pn = m.theo.Pn[as.vector(m.theo.index), ]
# Calculate groups, means and quantiles.
theo.Pn.group = CalculateGroupsMeansQuantiles(m.theo.Pn, n.mut.p, n.prot)
mean.theo.Pn.group = theo.Pn.group$mean.mean.group
theo.Pn.group.quantile1 = theo.Pn.group$mean.quantile1.group
theo.Pn.group.quantile2 = theo.Pn.group$mean.quantile2.group
theo.Pn.quantile1.mean = theo.Pn.group$quantile1.mean
theo.Pn.quantile2.mean = theo.Pn.group$quantile2.mean
m.mean.theo.Pn.group[as.vector(all.betas == beta), 1:length(mean.theo.Pn.group)] = mean.theo.Pn.group
m.theo.Pn.group.quantile1[as.vector(all.betas == beta), 1:length(theo.Pn.group.quantile1)] = theo.Pn.group.quantile1
m.theo.Pn.group.quantile2[as.vector(all.betas == beta), 1:length(theo.Pn.group.quantile2)] = theo.Pn.group.quantile2
m.theo.Pn.quantile1.mean[as.vector(all.betas == beta), 1:length(theo.Pn.quantile1.mean)] = theo.Pn.quantile1.mean
m.theo.Pn.quantile2.mean[as.vector(all.betas == beta), 1:length(theo.Pn.quantile2.mean)] = theo.Pn.quantile2.mean
Pn.fit = lm(mean.exp.Pn ~  mean.theo.Pn.group)
Pn.fit = fitted.values(Pn.fit)
Pn.R2 = cor(mean.exp.Pn, Pn.fit) ^ 2
Pn.MSE = mean((Pn.fit - mean.exp.Pn) ^ 2)
m.Pn.fit[as.vector(all.betas == beta), ] = Pn.fit
m.Pn.R2[as.vector(all.betas == beta), ] = Pn.R2
m.Pn.MSE[as.vector(all.betas == beta), ] = Pn.MSE
m.mean.exp.Pn[as.vector(all.betas == beta), 1:(length(mean.exp.Pn))] = mean.exp.Pn
}
# Source functions.
source("FUNCTIONS/CalculateGroupsMeansQuantiles.R")
# Set directories.
data.dir <- "DATA"
out.dir <- "OUT"
# p.ref.
n.sites.p.ref = read.csv(file.path(out.dir, paste(family, "_out_m.n.sites.p.ref.csv", sep = "")))$V1[1]
# Create matrices to save data.
m.MSDi.fit = matrix(nrow = 4, ncol = n.sites.p.ref)
m.exp.MSDi = matrix(nrow = 4, ncol = n.sites.p.ref)
m.MSDi.R2 = matrix(nrow = 4, ncol = 1)
m.MSDi.MSE = matrix(nrow = 4, ncol = 1)
m.Pn.fit = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.exp.Pn = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.Pn.R2 = matrix(nrow = 4, ncol = 1)
m.Pn.MSE = matrix(nrow = 4, ncol = 1)
m.mean.theo.Pn.group = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.theo.Pn.group.quantile1 = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.theo.Pn.group.quantile2 = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.theo.Pn.quantile1.mean = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.theo.Pn.quantile2.mean = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.mean.exp.Pn = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.exp.Pn.quantile1 = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
m.exp.Pn.quantile2 = matrix(nrow = 4, ncol = 3 * n.sites.p.ref)
# Read betas.
betas.fname.id <- paste(family, "_", p.ref, "_R0_", R0, sep = "")
all.betas <- read.csv(file.path(out.dir, paste(betas.fname.id, "_out_all.betas.csv", sep = "")))
# Start a loop for each beta.
for (beta in all.betas)  {
### Experimental ###
analysis.fname.id <- paste(family, "_R0_", R0, "_beta_", beta, "_K.analysis_", K.analysis, sep = "")
m.exp.Pn = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.Pn.csv", sep = "")))[, 1:100]
mean.exp.Pn = colMeans(m.exp.Pn)
n.prot = nrow(m.exp.Pn)
exp.Pn.quantile1 = matrix(ncol = ncol(m.exp.Pn), nrow = 1)
exp.Pn.quantile2 = matrix(ncol = ncol(m.exp.Pn), nrow = 1)
for (i in (1:ncol(m.exp.Pn))) {
exp.Pn.quantiles = as.vector(quantile((m.exp.Pn[, i]), probs = c(0.05, 0.95)))
exp.Pn.quantile1[1, i] = exp.Pn.quantiles[1]
exp.Pn.quantile2[1, i] = exp.Pn.quantiles[2]
}
m.mean.exp.Pn[as.vector(all.betas == beta), 1:length(mean.exp.Pn)] = mean.exp.Pn
m.exp.Pn.quantile1[as.vector(all.betas == beta), 1:length(exp.Pn.quantile1)] = exp.Pn.quantile1
m.exp.Pn.quantile2[as.vector(all.betas == beta), 1:length(exp.Pn.quantile2)] = exp.Pn.quantile2
m.exp.smooth.norm.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.norm.dr.squarei.csv", sep = "")))
exp.smooth.norm.MSDi = colMeans(m.exp.smooth.norm.dr.squarei, na.rm = T )
### Theoretical ###
m.theo.Pn = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.Pn.csv", sep = "")))[, 1:100]
m.theo.smooth.norm.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.norm.dr.squarei.csv", sep = "")))
theo.smooth.norm.MSDi = colMeans(m.theo.smooth.norm.dr.squarei, na.rm = T )
n.mut = nrow(m.theo.Pn)
fit = lm(exp.smooth.norm.MSDi ~ theo.smooth.norm.MSDi )
MSDi.fit = fitted.values(fit)
MSDi.R2 = cor(exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)], MSDi.fit) ^ 2
MSDi.MSE = mean((MSDi.fit - exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]) ^ 2)
exp.smooth.norm.MSDi = exp.smooth.norm.MSDi[!is.na(exp.smooth.norm.MSDi)]
m.MSDi.fit[as.vector(all.betas == beta), ] = MSDi.fit
m.MSDi.R2[as.vector(all.betas == beta), ] = MSDi.R2
m.MSDi.MSE[as.vector(all.betas == beta), ] = MSDi.MSE
m.exp.MSDi[as.vector(all.betas == beta), ] = exp.smooth.norm.MSDi
### Pn ###
# Re-ordenate Pn.
m.theo.index = matrix(ncol = 1, nrow = n.mut)
for (P in (1:n.prot)) {
for (mut in (1:n.mut.p)) {
m.theo.index[(P - 1) * n.mut.p + mut, ] = ((mut - 1) * 10 + P)
}
}
m.theo.Pn = m.theo.Pn[as.vector(m.theo.index), ]
# Calculate groups, means and quantiles.
theo.Pn.group = CalculateGroupsMeansQuantiles(m.theo.Pn, n.mut.p, n.prot)
mean.theo.Pn.group = theo.Pn.group$mean.mean.group
theo.Pn.group.quantile1 = theo.Pn.group$mean.quantile1.group
theo.Pn.group.quantile2 = theo.Pn.group$mean.quantile2.group
theo.Pn.quantile1.mean = theo.Pn.group$quantile1.mean
theo.Pn.quantile2.mean = theo.Pn.group$quantile2.mean
m.mean.theo.Pn.group[as.vector(all.betas == beta), 1:length(mean.theo.Pn.group)] = mean.theo.Pn.group
m.theo.Pn.group.quantile1[as.vector(all.betas == beta), 1:length(theo.Pn.group.quantile1)] = theo.Pn.group.quantile1
m.theo.Pn.group.quantile2[as.vector(all.betas == beta), 1:length(theo.Pn.group.quantile2)] = theo.Pn.group.quantile2
m.theo.Pn.quantile1.mean[as.vector(all.betas == beta), 1:length(theo.Pn.quantile1.mean)] = theo.Pn.quantile1.mean
m.theo.Pn.quantile2.mean[as.vector(all.betas == beta), 1:length(theo.Pn.quantile2.mean)] = theo.Pn.quantile2.mean
Pn.fit = lm(mean.exp.Pn ~  mean.theo.Pn.group)
Pn.fit = fitted.values(Pn.fit)
Pn.R2 = cor(mean.exp.Pn, Pn.fit) ^ 2
Pn.MSE = mean((Pn.fit - mean.exp.Pn) ^ 2)
m.Pn.fit[as.vector(all.betas == beta), 1:(length(Pn.fit))] = Pn.fit
m.Pn.R2[as.vector(all.betas == beta), ] = Pn.R2
m.Pn.MSE[as.vector(all.betas == beta), ] = Pn.MSE
m.mean.exp.Pn[as.vector(all.betas == beta), 1:(length(mean.exp.Pn))] = mean.exp.Pn
}
plot(m.mean.theo.Pn.group[1, ], m.mean.exp.Pn[1, ], xlab = "Pn promedio de promedios teorico", ylab = "Pn promedio experimental", main = "Pn")
abline(0, 1)
legend("topleft", paste("R^2", round(m.Pn.R2[1, ], digits = 2)), bty = "n", text.col = "red")
legend("bottomright", paste("MSE", signif(m.Pn.MSE[1, ], digits = 2)), bty = "n", text.col = "red")
plot(m.mean.theo.Pn.group[4, ], m.mean.exp.Pn[4, ], xlab = "Pn promedio de promedios teorico", ylab = "Pn promedio experimental", main = "No selection")
abline(0, 1)
legend("topleft", paste("R^2", round(m.Pn.R2[4, ], digits = 2)), bty = "n", text.col = "red")
legend("bottomright", paste("MSE", signif(m.Pn.MSE[4, ], digits = 2)), bty = "n", text.col = "red")
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Satart a loop for each family.
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
chain.p.ref = input$chain.p.ref[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReportAllBetas.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_beta_", beta, "_K.analysis_", K.analysis, ".html", sep = ''))
}
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Satart a loop for each family.
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
chain.p.ref = input$chain.p.ref[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReportAllBetas.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
plot(as.numeric(m.MSDi.fit[1, ]), xlab = "site", main = "MSDi strong selection", ylim = c(0,3))
points(m.exp.MSDi[1, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[1, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[1, ], digits = 4)), bty = "n", text.col = "red")
layout(matrix(1:4, 2, 2, byrow = T))
plot(as.numeric(m.MSDi.fit[1, ]), xlab = "site", main = "MSDi strong selection", ylab = "MSDi", ylim = c(0,3))
points(m.exp.MSDi[1, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[1, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[1, ], digits = 4)), bty = "n", text.col = "red")
plot(as.numeric(m.MSDi.fit[2, ]), xlab = "site", main = "MSDi medium selection", ylab = "MSDi", ylim = c(0,3))
points(m.exp.MSDi[2, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[2, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[2, ], digits = 4)), bty = "n", text.col = "red")
plot(as.numeric(m.MSDi.fit[3, ]), xlab = "site", main = "MSDi weak selection", ylab = "MSDi", ylim = c(0,3))
points(m.exp.MSDi[3, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[3, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[3, ], digits = 4)), bty = "n", text.col = "red")
plot(as.numeric(m.MSDi.fit[4, ]), xlab = "site", main = "MSDi no selection", ylab = "MSDi", ylim = c(0,3))
points(m.exp.MSDi[4, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[4, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[4, ], digits = 4)), bty = "n", text.col = "red")
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Satart a loop for each family.
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
chain.p.ref = input$chain.p.ref[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReportAllBetas.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
layout(matrix(1:4, 2, 2, byrow = T))
plot(as.numeric(m.MSDi.fit[1, ]), xlab = "site", main = "MSDi strong selection", ylab = "MSDi", ylim = c(0,5))
points(m.exp.MSDi[1, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[1, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[1, ], digits = 4)), bty = "n", text.col = "red")
plot(as.numeric(m.MSDi.fit[2, ]), xlab = "site", main = "MSDi medium selection", ylab = "MSDi", ylim = c(0,5))
points(m.exp.MSDi[2, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[2, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[2, ], digits = 4)), bty = "n", text.col = "red")
plot(as.numeric(m.MSDi.fit[3, ]), xlab = "site", main = "MSDi weak selection", ylab = "MSDi", ylim = c(0,5))
points(m.exp.MSDi[3, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[3, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[3, ], digits = 4)), bty = "n", text.col = "red")
plot(as.numeric(m.MSDi.fit[4, ]), xlab = "site", main = "MSDi no selection", ylab = "MSDi", ylim = c(0,5))
points(m.exp.MSDi[4, ], col = "red")
legend("topleft", paste("R^2", round(m.MSDi.R2[4, ], digits = 2), " ", "MSE", signif(m.MSDi.MSE[4, ], digits = 4)), bty = "n", text.col = "red")
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Satart a loop for each family.
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
chain.p.ref = input$chain.p.ref[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReportAllBetas.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Satart a loop for each family.
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
chain.p.ref = input$chain.p.ref[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReportAllBetas.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
n = 3 # Colocar el número de repeticiones de cada tratamiento.
valores <- c(25, 28, 40, 55, 35, 57, 73, 28, 75) #colocar los valores de cada tratamiento#
tratamiento <- rep(c("T1", "T2", "T3"), c(n, n, n)) #agregar tantas Ti como tratamientos#
tratamiento
n = 3 # Colocar el número de repeticiones de cada tratamiento.
valores = c(25, 28, 40, 55, 35, 57, 73, 28, 75) #colocar los valores de cada tratamiento#
tratamiento <- rep(c("T1", "T2", "T3"), c(n, n, n)) #agregar tantas Ti como tratamientos#
### INPUT ###
n = 3 # Colocar el número de repeticiones de cada tratamiento.
valores = c(25, 28, 40, 55, 35, 57, 73, 28, 75) #colocar los valores de cada tratamiento#
tratamiento <- rep(c("T1", "T2", "T3"), c(n, n, n)) #agregar tantas Ti como tratamientos#
### PROGRAMA ###
tratamiento <- factor(tratamiento)
# ANOVA #
mm.aov <- aov(valores ~ tratamiento)
summary(mm.aov)
# TEST TUKEY #
TukeyHSD(mm.aov, conf.level= 0.95)
# INTERVALOS DE CONFIANZA #
plot(TukeyHSD(mm.aov, conf.level= 0.95))
summary(mm.aov)
TukeyHSD(mm.aov, conf.level= 0.95)
TukeyHSD(mm.aov, conf.level= 0.90)
plot(TukeyHSD(mm.aov, conf.level= 0.90))
t.test(c(55, 35, 57), c(25, 28, 40), alternative = "g")
t.test(c(55, 35, 57), c(25, 28, 40), alternative = "g", conf.level = 0.9)
t.test(c(55, 35, 57), c(25, 28, 40), alternative = "l", conf.level = 0.9)
t.test(c(73, 28, 75), c(25, 28, 40), alternative = "g", conf.level = 0.9)
help("t.test")
t.test(c(55, 35, 57), c(25, 28, 40), alternative = "t", conf.level = 0.9)
t.test(c(73, 28, 75), c(25, 28, 40), alternative = "t", conf.level = 0.9)
t.test(c(55, 35, 57), c(25, 28, 40), alternative = "g", conf.level = 0.9)
t.test(c(73, 28, 75), c(25, 28, 40), alternative = "g", conf.level = 0.9)
t.test(c(55, 35, 57), c(73, 28, 75), alternative = "g", conf.level = 0.9)
t.test(c(55, 35, 57), c(73, 28, 75), alternative = "l", conf.level = 0.9)
t.test(c(55, 35, 57), c(73, 28, 75), alternative = "t", conf.level = 0.9)
t.test(c(55, 35, 57), c(25, 28, 40), alternative = "g", conf.level = 0.9)
summary(mm.aov)
t.test(c(55, 35, 57), c(25, 28, 40), alternative = "g", conf.level = 0.9)
t.test(c(73, 28, 75), c(25, 28, 40), alternative = "g", conf.level = 0.9)
t.test(c(55, 35, 57), c(73, 28, 75), alternative = "t", conf.level = 0.9)
# Load packages.
library(knitr)
library(markdown)
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Satart a loop for each family.
for (a in (1:nrow(input))) {
print(a)
family <- as.character(input$family)[a]
p.ref <- as.character(input$p.ref)[a]
chain.p.ref = input$chain.p.ref[a]
n.mut.p = input$n.mut.p[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
# Generate a report.
rmarkdown::render('MultipleReportAllBetas.Rmd',
output_file =  paste("report_", family, "_R0_", R0, "_K.analysis_", K.analysis, ".html", sep = ''))
}
