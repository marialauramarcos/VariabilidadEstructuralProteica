#    - data.dir: directory of the data.
#    - out.dir: directory for the output.
#
#  Required libraries:
#    {Bio3d}
#
#  Required functions:
#    ReadCA()
#    ReadHeme()
#    CalculateSideChainCM()
CalculateMinDaCMCA <- function(family,
p.ref,
chain.p.ref,
heme,
data.dir,
out.dir) {
# read functional sites
active = read.csv(file.path(data.dir, paste(p.ref, "_functionalSites.csv", sep = "")), sep = ";")$index
active = active[!is.na(active)]
# pdb filename
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
# get coordinates of p.ref
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CM.p.ref = CalculateSideChainCM(pdb.fname, chain.p.ref)
n.aa = ncol(r.CA.p.ref)
if (heme == "TRUE") {
r.heme = ReadHeme(pdb.fname, chain.p.ref)
r.CA.p.ref = cbind(r.CA.p.ref, r.heme)
r.CM.p.ref = cbind(r.CM.p.ref, r.heme)
}
# calculate the number of sites
n.sites = ncol(r.CA.p.ref)
# calculate the distances between each site and each functional site (CA or CM)
m.da.CA = matrix(nrow = n.sites, ncol = length(active))
m.da.CM = matrix(nrow = n.sites, ncol = length(active))
for (i in (active)) {
print(i)
for (j in (1:n.sites)) {
m.da.CA[j, which(active == i)] = sqrt(sum((r.CA.p.ref[, j] - r.CA.p.ref[, i]) ^ 2))
m.da.CM[j, which(active == i)] = sqrt(sum((r.CM.p.ref[, j] - r.CM.p.ref[, i]) ^ 2))
}
}
m.da.CA = cbind(seq(1:n.sites), m.da.CA)
colnames(m.da.CA) = c("site", paste("da", seq(1:length(active)), sep = ""))
m.da.CM = cbind(seq(1:n.sites), m.da.CM)
colnames(m.da.CM) = c("site", paste("da", seq(1:length(active)), sep = ""))
if (family == "globins") {
m.da.CA = m.da.CA[1:n.aa, ]
m.da.CM = m.da.CM[1:n.aa, ]
}
# calculate the minimum distance of each site to the active sites
m.min.da.CA = matrix(nrow = n.aa, ncol = 1)
m.min.da.CM = matrix(nrow = n.aa, ncol = 1)
for (i in (1:n.aa)) {
m.min.da.CA[i, ] = min(m.da.CA[i, 2:ncol(m.da.CA)])
m.min.da.CM[i, ] = min(m.da.CM[i, 2:ncol(m.da.CM)])
}
# build a dataframe with minimum distances
min.da.data = data.frame("site" = seq(1:n.aa),
"min.da.CM" = as.vector(m.min.da.CM),
"min.da.CA" = as.vector(m.min.da.CA))
# write output files
write.csv(min.da.data, file.path(out.dir, paste(p.ref, "_min.da.CM.ca.csv", sep = "")))
write.csv(m.da.CA, file.path(out.dir, paste(p.ref, "_m.da.ca.csv", sep = "")))
write.csv(m.da.CM, file.path(out.dir, paste(p.ref, "_m.da.CM.csv", sep = "")))
}
2:5
CalculateMinDaCMCA(family,
p.ref,
chain.p.ref,
heme,
data.dir,
out.dir)
m.da.ca
rowSums(1/m.da.ca[1,2:5])
rowSums(1/m.da.ca[,2:5])
rowSums(1/m.da.ca[,2:5], na.rm = T)
rowSums(1/m.da.ca[,2:5], Inf = T)
rowSums(1/m.da.ca[,2:5])
plot(rowSums(1/m.da.ca[,2:5]))
rowSums(1/m.da.CA[i, 2:ncol(m.da.CA)])
rowSums(1/m.da.CA[, 2:ncol(m.da.CA)])
1/m.da.CA[, 2:ncol(m.da.CA)]
inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
inv.da.CA[is.infinite(inv.da.CA)] <- NA
inv.da.CA
inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
inv.da.CA
inv.da.CA[is.infinite(inv.da.CA)] <- NA
inv.da.CA
sum.inv.da.CA = rowSums(1/m.da.CA[, 2:ncol(m.da.CA)], na.rm = T)
sum.inv.da.CA
inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
inv.da.CA[is.infinite(inv.da.CA)] <- NA
sum.inv.da.CA = rowSums(inv.da.CA, na.rm = T)
sum.inv.da.CA
plot(sum.inv.da.CA)
plot(scale(sum.inv.da.CA))
plot(sum.inv.da.CA)
plot(min.da.CA)
plot(min.m.da.CA)
plot(m.min.da.CA)
plot(scale(m.min.da.CA))
points(scale(sum.inv.da.CA), col = "red")
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
cor(m.min.da.CA, m.sum.inv.da.CA)
plot(scale(m.min.da.CA))
points(-scale(sum.inv.da.CA), col = "red")
m.da.CA
m.da.CA[,2]
2
26
=1/2
1/2
1/23
# Description:
#
# This function calculates distances between functional sites of a protein and the other sites of the protein.
# It calculates distances between both CAs and CMs of the side chains of aminoacids.
#
# Usage:
#
# CalculateDaCMCA(family,
#                    p.ref,
#                    chain.p.ref,
#                    heme = TRUE/FALSE,
#                    data.dir,
#                    out.dir)
#
#  Args:
#    - family: The family of the protein to mutate.
#    - p.ref: The pdb code (pdbid) of the protein to mutate (example: "1a6m"). The protein must be a member of
#    the selected family.
#    - chain.p.ref: The chain of p.ref in the pdb file obtained from Homstrad.
#    - heme: argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - data.dir: directory of the data.
#    - out.dir: directory for the output.
#
#  Required libraries:
#    {Bio3d}
#
#  Required functions:
#    ReadCA()
#    ReadHeme()
#    CalculateSideChainCM()
CalculateDaCMCA <- function(family,
p.ref,
chain.p.ref,
heme,
data.dir,
out.dir) {
# read functional sites
active = read.csv(file.path(data.dir, paste(p.ref, "_functionalSites.csv", sep = "")), sep = ";")$index
active = active[!is.na(active)]
# pdb filename
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
# get coordinates of p.ref
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CM.p.ref = CalculateSideChainCM(pdb.fname, chain.p.ref)
n.aa = ncol(r.CA.p.ref)
if (heme == "TRUE") {
r.heme = ReadHeme(pdb.fname, chain.p.ref)
r.CA.p.ref = cbind(r.CA.p.ref, r.heme)
r.CM.p.ref = cbind(r.CM.p.ref, r.heme)
}
# calculate the number of sites
n.sites = ncol(r.CA.p.ref)
# calculate the distances between each site and each functional site (CA or CM)
m.da.CA = matrix(nrow = n.sites, ncol = length(active))
m.da.CM = matrix(nrow = n.sites, ncol = length(active))
for (i in (active)) {
for (j in (1:n.sites)) {
m.da.CA[j, which(active == i)] = sqrt(sum((r.CA.p.ref[, j] - r.CA.p.ref[, i]) ^ 2))
m.da.CM[j, which(active == i)] = sqrt(sum((r.CM.p.ref[, j] - r.CM.p.ref[, i]) ^ 2))
}
}
m.da.CA = cbind(seq(1:n.sites), m.da.CA)
colnames(m.da.CA) = c("site", paste("da", seq(1:length(active)), sep = ""))
m.da.CM = cbind(seq(1:n.sites), m.da.CM)
colnames(m.da.CM) = c("site", paste("da", seq(1:length(active)), sep = ""))
if (family == "globins") {
m.da.CA = m.da.CA[1:n.aa, ]
m.da.CM = m.da.CM[1:n.aa, ]
}
# calculate the minimum distance of each site to the active sites
m.min.da.CA = matrix(nrow = n.aa, ncol = 1)
m.min.da.CM = matrix(nrow = n.aa, ncol = 1)
for (i in (1:n.aa)) {
m.min.da.CA[i, ] = min(m.da.CA[i, 2:ncol(m.da.CA)])
m.min.da.CM[i, ] = min(m.da.CM[i, 2:ncol(m.da.CM)])
}
# calculate a measure of all distances to the active site
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
m.inv.da.CM = 1/m.da.CA[, 2:ncol(m.da.CM)]
m.inv.da.CM[is.infinite(m.inv.da.CM)] <- NA
m.sum.inv.da.CM = rowSums(m.inv.da.CM, na.rm = T)
# build a dataframe with minimum distances
min.da.data = data.frame("site" = seq(1:n.aa),
"min.da.CM" = as.vector(m.min.da.CM),
"min.da.CA" = as.vector(m.min.da.CA))
# build a dataframe with sum.inv distances
sum.inv.da.data = data.frame("site" = seq(1:n.aa),
"sum.inv.da.CM" = as.vector(m.sum.inv.da.CM),
"sum.inv.da.CA" = as.vector(m.sum.inv.da.CA))
# write output files
write.csv(min.da.data, file.path(out.dir, paste(p.ref, "_min.da.CM.ca.csv", sep = "")))
write.csv(sum.inv.da.data, file.path(out.dir, paste(p.ref, "_sum.inv.da.CM.ca.csv", sep = "")))
write.csv(m.da.CA, file.path(out.dir, paste(p.ref, "_m.da.ca.csv", sep = "")))
write.csv(m.da.CM, file.path(out.dir, paste(p.ref, "_m.da.CM.csv", sep = "")))
}
# read functional sites
active = read.csv(file.path(data.dir, paste(p.ref, "_functionalSites.csv", sep = "")), sep = ";")$index
active = active[!is.na(active)]
# pdb filename
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
# get coordinates of p.ref
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CM.p.ref = CalculateSideChainCM(pdb.fname, chain.p.ref)
n.aa = ncol(r.CA.p.ref)
if (heme == "TRUE") {
r.heme = ReadHeme(pdb.fname, chain.p.ref)
r.CA.p.ref = cbind(r.CA.p.ref, r.heme)
r.CM.p.ref = cbind(r.CM.p.ref, r.heme)
}
# calculate the number of sites
n.sites = ncol(r.CA.p.ref)
# calculate the distances between each site and each functional site (CA or CM)
m.da.CA = matrix(nrow = n.sites, ncol = length(active))
m.da.CM = matrix(nrow = n.sites, ncol = length(active))
for (i in (active)) {
for (j in (1:n.sites)) {
m.da.CA[j, which(active == i)] = sqrt(sum((r.CA.p.ref[, j] - r.CA.p.ref[, i]) ^ 2))
m.da.CM[j, which(active == i)] = sqrt(sum((r.CM.p.ref[, j] - r.CM.p.ref[, i]) ^ 2))
}
}
m.da.CA = cbind(seq(1:n.sites), m.da.CA)
colnames(m.da.CA) = c("site", paste("da", seq(1:length(active)), sep = ""))
m.da.CM = cbind(seq(1:n.sites), m.da.CM)
colnames(m.da.CM) = c("site", paste("da", seq(1:length(active)), sep = ""))
if (family == "globins") {
m.da.CA = m.da.CA[1:n.aa, ]
m.da.CM = m.da.CM[1:n.aa, ]
}
# calculate the minimum distance of each site to the active sites
m.min.da.CA = matrix(nrow = n.aa, ncol = 1)
m.min.da.CM = matrix(nrow = n.aa, ncol = 1)
for (i in (1:n.aa)) {
m.min.da.CA[i, ] = min(m.da.CA[i, 2:ncol(m.da.CA)])
m.min.da.CM[i, ] = min(m.da.CM[i, 2:ncol(m.da.CM)])
}
# calculate a measure of all distances to the active site
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
m.inv.da.CM = 1/m.da.CA[, 2:ncol(m.da.CM)]
m.inv.da.CM[is.infinite(m.inv.da.CM)] <- NA
m.sum.inv.da.CM = rowSums(m.inv.da.CM, na.rm = T)
# build a dataframe with minimum distances
min.da.data = data.frame("site" = seq(1:n.aa),
"min.da.CM" = as.vector(m.min.da.CM),
"min.da.CA" = as.vector(m.min.da.CA))
family
cor(as.vector(m.min.da.CM), as.vector(m.sum.inv.da.CM))
cor(as.vector(m.min.da.CA), as.vector(m.sum.inv.da.CA))
CalculateDaCMCA.fname <- "FUNCTIONS/CalculateDaCMCA.R"
source(CalculateDaCMCA.fname)
# calculate distances to the active site
CalculateDaCMCA(family,
p.ref,
chain.p.ref,
heme,
data.dir,
out.dir)
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA = 1/(m.da.CA[, 2:ncol(m.da.CA)])^2
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
cor(as.vector(m.min.da.CA), as.vector(m.sum.inv.da.CA))
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
cor(as.vector(m.min.da.CA), as.vector(m.sum.inv.da.CA))
m.inv.da.CM = 1/m.da.CA[, 2:ncol(m.da.CM)]
m.inv.da.CM[is.infinite(m.inv.da.CM)] <- NA
m.sum.inv.da.CM = rowSums(m.inv.da.CM, na.rm = T)
cor(as.vector(m.min.da.CM), as.vector(m.sum.inv.da.CM))
m.inv.da.CM = 1/m.da.CA[, 2:ncol(m.da.CM)]
m.inv.da.CM = 1/(m.da.CA[, 2:ncol(m.da.CM)])^2
m.inv.da.CM[is.infinite(m.inv.da.CM)] <- NA
m.sum.inv.da.CM = rowSums(m.inv.da.CM, na.rm = T)
cor(as.vector(m.min.da.CM), as.vector(m.sum.inv.da.CM))
plot(m.sum.inv.da.CA)
plot(scale(m.min.da.CA))
points(scale(m.inv.da.CA), col = "red")
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
plot(scale(m.min.da.CA))
points(scale(m.inv.da.CA), col = "red")
plot(scale(m.min.da.CA))
points(scale(as.vector(m.sum.inv.da.CA)), col = "red")
plot(scale(m.min.da.CA))
points(-scale(as.vector(m.sum.inv.da.CA)), col = "red")
active = 24
m.da.CA = matrix(nrow = n.sites, ncol = length(active))
m.da.CM = matrix(nrow = n.sites, ncol = length(active))
for (i in (active)) {
for (j in (1:n.sites)) {
m.da.CA[j, which(active == i)] = sqrt(sum((r.CA.p.ref[, j] - r.CA.p.ref[, i]) ^ 2))
m.da.CM[j, which(active == i)] = sqrt(sum((r.CM.p.ref[, j] - r.CM.p.ref[, i]) ^ 2))
}
}
active = c(24,88)
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
# get coordinates of p.ref
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CM.p.ref = CalculateSideChainCM(pdb.fname, chain.p.ref)
n.aa = ncol(r.CA.p.ref)
if (heme == "TRUE") {
r.heme = ReadHeme(pdb.fname, chain.p.ref)
r.CA.p.ref = cbind(r.CA.p.ref, r.heme)
r.CM.p.ref = cbind(r.CM.p.ref, r.heme)
}
# calculate the number of sites
n.sites = ncol(r.CA.p.ref)
# calculate the distances between each site and each functional site (CA or CM)
m.da.CA = matrix(nrow = n.sites, ncol = length(active))
m.da.CM = matrix(nrow = n.sites, ncol = length(active))
for (i in (active)) {
for (j in (1:n.sites)) {
m.da.CA[j, which(active == i)] = sqrt(sum((r.CA.p.ref[, j] - r.CA.p.ref[, i]) ^ 2))
m.da.CM[j, which(active == i)] = sqrt(sum((r.CM.p.ref[, j] - r.CM.p.ref[, i]) ^ 2))
}
}
m.da.CA = cbind(seq(1:n.sites), m.da.CA)
colnames(m.da.CA) = c("site", paste("da", seq(1:length(active)), sep = ""))
m.da.CM = cbind(seq(1:n.sites), m.da.CM)
colnames(m.da.CM) = c("site", paste("da", seq(1:length(active)), sep = ""))
if (family == "globins") {
m.da.CA = m.da.CA[1:n.aa, ]
m.da.CM = m.da.CM[1:n.aa, ]
}
# calculate the minimum distance of each site to the active sites
m.min.da.CA = matrix(nrow = n.aa, ncol = 1)
m.min.da.CM = matrix(nrow = n.aa, ncol = 1)
for (i in (1:n.aa)) {
m.min.da.CA[i, ] = min(m.da.CA[i, 2:ncol(m.da.CA)])
m.min.da.CM[i, ] = min(m.da.CM[i, 2:ncol(m.da.CM)])
}
# calculate a measure of all distances to the active site
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
m.inv.da.CM = 1/m.da.CA[, 2:ncol(m.da.CM)]
m.inv.da.CM[is.infinite(m.inv.da.CM)] <- NA
m.sum.inv.da.CM = rowSums(m.inv.da.CM, na.rm = T)
# build a dataframe with minimum distances
min.da.data = data.frame("site" = seq(1:n.aa),
"min.da.CM" = as.vector(m.min.da.CM),
"min.da.CA" = as.vector(m.min.da.CA))
# build a dataframe with sum.inv distances
sum.inv.da.data = data.frame("site" = seq(1:n.aa),
"sum.inv.da.CM" = as.vector(m.sum.inv.da.CM),
"sum.inv.da.CA" = as.vector(m.sum.inv.da.CA))
points(-scale(m.sum.inv.da.CA), col = "blue")
points(scale(m.sum.inv.da.CA), col = "green")
active
# read functional sites
active = read.csv(file.path(data.dir, paste(p.ref, "_functionalSites.csv", sep = "")), sep = ";")$index
active = active[!is.na(active)]
# pdb filename
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
# get coordinates of p.ref
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CM.p.ref = CalculateSideChainCM(pdb.fname, chain.p.ref)
n.aa = ncol(r.CA.p.ref)
if (heme == "TRUE") {
r.heme = ReadHeme(pdb.fname, chain.p.ref)
r.CA.p.ref = cbind(r.CA.p.ref, r.heme)
r.CM.p.ref = cbind(r.CM.p.ref, r.heme)
}
# calculate the number of sites
n.sites = ncol(r.CA.p.ref)
# calculate the distances between each site and each functional site (CA or CM)
m.da.CA = matrix(nrow = n.sites, ncol = length(active))
m.da.CM = matrix(nrow = n.sites, ncol = length(active))
for (i in (active)) {
for (j in (1:n.sites)) {
m.da.CA[j, which(active == i)] = sqrt(sum((r.CA.p.ref[, j] - r.CA.p.ref[, i]) ^ 2))
m.da.CM[j, which(active == i)] = sqrt(sum((r.CM.p.ref[, j] - r.CM.p.ref[, i]) ^ 2))
}
}
m.da.CA = cbind(seq(1:n.sites), m.da.CA)
colnames(m.da.CA) = c("site", paste("da", seq(1:length(active)), sep = ""))
m.da.CM = cbind(seq(1:n.sites), m.da.CM)
colnames(m.da.CM) = c("site", paste("da", seq(1:length(active)), sep = ""))
if (family == "globins") {
m.da.CA = m.da.CA[1:n.aa, ]
m.da.CM = m.da.CM[1:n.aa, ]
}
# calculate the minimum distance of each site to the active sites
m.min.da.CA = matrix(nrow = n.aa, ncol = 1)
m.min.da.CM = matrix(nrow = n.aa, ncol = 1)
for (i in (1:n.aa)) {
m.min.da.CA[i, ] = min(m.da.CA[i, 2:ncol(m.da.CA)])
m.min.da.CM[i, ] = min(m.da.CM[i, 2:ncol(m.da.CM)])
}
# calculate a measure of all distances to the active site
m.inv.da.CA = 1/m.da.CA[, 2:ncol(m.da.CA)]
m.inv.da.CA[is.infinite(m.inv.da.CA)] <- NA
m.sum.inv.da.CA = rowSums(m.inv.da.CA, na.rm = T)
m.inv.da.CM = 1/m.da.CA[, 2:ncol(m.da.CM)]
m.inv.da.CM[is.infinite(m.inv.da.CM)] <- NA
m.sum.inv.da.CM = rowSums(m.inv.da.CM, na.rm = T)
# build a dataframe with minimum distances
min.da.data = data.frame("site" = seq(1:n.aa),
"min.da.CM" = as.vector(m.min.da.CM),
"min.da.CA" = as.vector(m.min.da.CA))
# build a dataframe with sum.inv distances
sum.inv.da.data = data.frame("site" = seq(1:n.aa),
"sum.inv.da.CM" = as.vector(m.sum.inv.da.CM),
"sum.inv.da.CA" = as.vector(m.sum.inv.da.CA))
sum.inv.da.data
points(scale(m.sum.inv.da.CA), col = "green")
chain.p.ref
p.ref
p.ref="1mcta"
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CA.p.ref
ReadCA
p.ref = "1a4fb"
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
# get coordinates of p.ref
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CA.p.ref
chain.p.ref = "g"
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CA.p.ref
p.ref
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
pdb.fname
chain.p.ref
chain.p.ref = "d"
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CA.p.ref
p.ref = "1jiaa"
chain.p.ref = "L"
pdb.fname <- file.path(data.dir, paste(p.ref, ".pdb", sep = ""))
# get coordinates of p.ref
r.CA.p.ref = ReadCA(pdb.fname, chain.p.ref)$xyz
r.CA.p.ref
pdb <- read.pdb(file = pdb.fname)
# get information from de pdb
sel.ca <- atom.select(pdb, chain = chain, elety = "CA")
chain = chain.p.ref
pdb <- read.pdb(file = pdb.fname)
# get information from de pdb
sel.ca <- atom.select(pdb, chain = chain, elety = "CA")
site.ca = as.numeric(pdb$atom[sel.ca$atom, c("resno")])
n.aa = length(site.ca)
sel <- atom.select(pdb, chain = chain, strain = "protein", resno = i)
site.elety <- pdb$atom[sel$atom, c("elety")]
pdb$atom[sel$atom, c("elety")]
atom.select(pdb, chain = chain, strain = "protein")
sel = atom.select(pdb, chain = chain, strain = "protein")
site.elety <- pdb$atom[sel$atom, c("elety")]
site.elety
sel = atom.select(pdb, chain = chain, strain = "protein", elety = "CA")
site.elety <- pdb$atom[sel$atom, c("elety")]
site.elety
site.resid <- pdb$atom[sel$atom, c("resid")]
site.resid
site.eleno <- pdb$atom[sel$atom, c("eleno")]
site.eleno
pdb <- read.pdb(file = pdb.fname)
sel.ca <- atom.select(pdb, chain = chain, elety = "CA")
sel.ca
site.ca = as.numeric(pdb$atom[sel.ca$atom, c("resno")])
site.ca
n.aa = length(site.ca)
pdb <- read.pdb(file = pdb.fname)
# get information from de pdb
sel.ca <- atom.select(pdb, chain = chain, elety = "CA")
site.ca = as.numeric(pdb$atom[sel.ca$atom, c("resno")])
n.aa = length(site.ca)
sel.ca
site.ca
n.aa = length(site.ca)
n.aa
xyz.side.chain.CM = matrix(nrow = 3, ncol = n.aa)
site = 0
key = 1
site.ca
runif(-1,1.1000)
runif(-1,1,1000)
runif(1000,-1,1)
mean(runif(1000,-1,1))
mean((runif(1000,-1,1))^2
)
mean((runif(1000,-1,1))^2)
mean((runif(1000,-2,2))^2)
mean((runif(1000,-2,2))^2)
mean((runif(1000,-2,2))^2)
