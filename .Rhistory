}
points(as.vector(m.exp.smooth.dr.squarei[P, ]),col="red")
# This is the main program of the project. The program simulates mutants of a given protein, analyzes the multiple
# alignment of the family to which the protein belongs, calculates measures of variabilty of theoretical and
# experimental data, compares them, and generates a report.
# To run the program it is necessary to fill the input file ("input_MainProgram.csv") with the following information:
#
#    - family: the family of the protein to mutate. It can be "globins", "serinProteases", "plastocyanins",
#    "snakesToxin", "sh3", "lipocalin", "fabp", "kinase", "rrm", "phoslip", "gluts" and "ldh".
#    - p.ref: the pdb code (pdbid) of the protein to mutate (example: "1a6m"). The protein must be a member of
#    the selected family. This pdbid must not be included in the dataset ("DATA/family_dataset.csv").
#    - exp.chain.p.ref: the chain of p.ref in the pdb file obtained from Homstrad.
#    - mut.model: mutational model. It can be "LFENM" ("Linearly Forced - Elastic Network Model") or "MND"
#    ("Multivariate Normal Distribution").
#    - n.mut.p: the number of mutants to generate for each member of the family. For example, if the family has 20
#    members, the program generates n.mut.p x 20 mutants.
#    - fmax: argument for "LFENM". It is the maximun value for the forces that model the mutations.
#    - R0: the cut-off for the ANM ("Anisotropic Network Model") that represents the proteins.
#    - rotate: it can be "TRUE" or "FALSE". If it is "TRUE", r.p.2 is rotated in order to minimize RMSD with r.p.ref.
#    - core: it can be "TRUE" or "FALSE". If it is "TRUE", the program only considers the conserved core of
#    the alignment. If it is "FALSE", the program analyzes the whole alignment.
#    - heme: argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - analyze.family: It can be "TRUE" or "FALSE". If it is "TRUE" the program analyzes the family.
#    - generate.mutants: It can be "TRUE" or "FALSE". If it is "TRUE" the program generates new mutants.
#    - natural.selection: It can be "TRUE" or "FALSE". If it is "TRUE", the mutants are calculated considering natural
#    selection. If it is "FALSE", the mutants are calculated in a random manner.
#    - K.analysis: It can be "K" or "Keff". For "K" or "Keff", the analysis is based on normal modes of "K" or "Keff"
#    respectibly.
# Remove objects.
rm(list = ls())
# Load packages.
library(bio3d)
library(flux)
library(knitr)
library(markdown)
library(MASS)
library(rmarkdown)
library(seqinr)
# Data dir.
data.dir <- "DATA"
# Output dir.
out.dir <- "OUT"
# General parameters.
TOLERANCE = 1e-10
# Functions filenames.
AnalyzeExperimentalTheoretical.fname <- "FUNCTIONS/AnalyzeExperimentalTheoretical.R"
AnalyzeFamily.fname <- "FUNCTIONS/AnalyzeFamily.R"
AnalyzeAlignment.fname <- "FUNCTIONS/AnalyzeAlignment.R"
GenerateMutants.fname <- "FUNCTIONS/GenerateMutants.R"
ReadFasta.fname <- "FUNCTIONS/ReadFasta.R"
ReadCA.fname <- "FUNCTIONS/ReadCA.R"
ReadHeme.fname <- "FUNCTIONS/ReadHeme.R"
CalculateENMKeff.fname <- "FUNCTIONS/CalculateENMKeff.R"
CalculateENMK.fname <- "FUNCTIONS/CalculateENMK.R"
CalculateKij.fname <- "FUNCTIONS/CalculateKij.R"
CalculateForce.fname <- "FUNCTIONS/CalculateForce.R"
CalculateVariability.fname <- "FUNCTIONS/CalculateVariability.R"
# Source functions.
source(AnalyzeExperimentalTheoretical.fname)
source(AnalyzeFamily.fname)
source(AnalyzeAlignment.fname)
source(GenerateMutants.fname)
source(ReadFasta.fname)
source(ReadCA.fname)
source(ReadHeme.fname)
source(CalculateENMKeff.fname)
source(CalculateENMK.fname)
source(CalculateKij.fname)
source(CalculateForce.fname)
source(CalculateVariability.fname)
# Read input.
input.fname <- file.path("input_MainProgram.csv")
input <- read.csv(input.fname)
for (a in (1:nrow(input))) {
family <- as.character(input$family)[a]
print(family)
p.ref <- as.character(input$p.ref)[a]
exp.chain.p.ref <- as.character(input$exp.chain.p.ref)[a]
mut.model = input$mut.model[a]
n.mut.p = input$n.mut.p[a]
fmax = input$fmax[a]
R0 = input$R0[a]
core <- input$core[a]
rotate <- input$rotate[a]
heme <- input$heme[a]
analyze.family <- input$analyze.familiy[a]
generate.mutants <- input$generate.mutants[a]
analyze.experimental.theoretical <- input$analyze.experimental.theoretical[a]
natural.selection <- input$natural.selection[a]
K.analysis <- input$K.analysis[a]
# Generate ids for output filenames.
mut.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", natural.selection, "_R0_", R0, sep = "")
analysis.fname.id <- paste(mut.fname.id, "_core_", core, "_K.analysis_", K.analysis, sep = "")
# Analyze the alignment of the family.
if (analyze.family == "TRUE") {
AnalyzeFamily(family,
p.ref,
data.dir,
out.dir)
}
# Generate mutants.
if (generate.mutants == "TRUE") {
GenerateMutants(family,
exp.chain.p.ref,
mut.model,
n.mut.p,
fmax,
R0,
heme,
natural.selection,
data.dir,
out.dir,
mut.fname.id,
TOLERANCE)
}
# Analyze measures of variability of experimental proteins and simulated mutants.
if (analyze.experimental.theoretical == "TRUE") {
AnalyzeExperimentalTheoretical(family,
exp.chain.p.ref,
n.mut.p,
R0,
core,
rotate,
heme,
natural.selection,
K.analysis,
data.dir,
out.dir,
mut.fname.id,
analysis.fname.id,
TOLERANCE)
}
}
#  Generate a report.
#  rmarkdown::render('Report.Rmd',
#                    output_file = paste("report_", analysis.fname.id, ".html", sep = ''))
#}
# Load packages.
library(bio3d)
library(flux)
library(knitr)
library(markdown)
library(MASS)
library(rmarkdown)
library(seqinr)
install.packages(bio3d)
install.packages("bio3d")
library(bio3d)
install.packages("flux")
install.packages("knitr")
install.packages("markdown")
install.packages("bio3d")
install.packages("flux")
install.packages("knitr")
install.packages("markdown")
install.packages("rmarkdown")
install.packages("MASS")
install.packages("seqinr")
sqrt(0.3)
sqrt(0.35)
sqrt(0.40)
sqrt(0.60)
sqrt(0.80)
# Chunk 1: setup
knitr::opts_chunk$set(warning = FALSE, echo = FALSE, message = FALSE)
# Chunk 2
# Directories.
out.dir <- "OUT"
# Create matrixes.
nsF.theo.MSDi = c()
nsT.theo.MSDi = c()
nsF.theo.MSDi.s = c()
nsT.theo.MSDi.s = c()
exp.MSDi = c()
exp.MSDi.s = c()
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Print the input in the html file.
print(input)
# Start a loop to read data for each family.
for (a in (1:nrow(input))) {
family <- as.character(input$family)[a]
mut.model = input$mut.model[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
#Read experimental data.
analysis.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", "FALSE", "_R0_", R0, "_core_", "FALSE", "_K.analysis_", K.analysis, sep = "")
m.cF.exp.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.dr.squarei.csv", sep = "")))
m.cF.exp.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.dr.squarei.csv", sep = "")))
cF.exp.MSDi = colMeans(m.cF.exp.dr.squarei, na.rm = T )
cF.exp.MSDi.s = colMeans(m.cF.exp.smooth.dr.squarei, na.rm = T )
#Read theoretical data#
# natural selection (ns) = F.
m.nsF.cF.theo.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.dr.squarei.csv", sep = "")))
m.nsF.cF.theo.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.dr.squarei.csv", sep = "")))
nsF.cF.theo.MSDi = colMeans(m.nsF.cF.theo.dr.squarei, na.rm = T)
nsF.cF.theo.MSDi.s = colMeans(m.nsF.cF.theo.smooth.dr.squarei, na.rm = T)
# natural selection (ns) = T.
analysis.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", "TRUE", "_R0_", R0, "_core_", "FALSE", "_K.analysis_", K.analysis, sep = "")
m.nsT.cF.theo.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.dr.squarei.csv", sep = "")))
m.nsT.cF.theo.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.dr.squarei.csv", sep = "")))
nsT.cF.theo.MSDi = colMeans(m.nsT.cF.theo.dr.squarei, na.rm = T)
nsT.cF.theo.MSDi.s = colMeans(m.nsT.cF.theo.smooth.dr.squarei, na.rm = T)
## Fit theoretical data with experimental data.
fit.nsF.cF = lm(cF.exp.MSDi ~ nsF.cF.theo.MSDi)
fit.nsF.cF.MSDi = fitted.values(fit.nsF.cF)
fit.nsT.cF = lm(cF.exp.MSDi ~ nsT.cF.theo.MSDi)
fit.nsT.cF.MSDi = fitted.values(fit.nsT.cF)
fit.nsF.cF.s = lm(cF.exp.MSDi.s ~ nsF.cF.theo.MSDi.s)
fit.nsF.cF.MSDi.s = fitted.values(fit.nsF.cF.s)
fit.nsT.cF.s = lm(cF.exp.MSDi.s ~ nsT.cF.theo.MSDi.s)
fit.nsT.cF.MSDi.s = fitted.values(fit.nsT.cF.s)
# Concatenate information.
nsF.theo.MSDi = c(nsF.theo.MSDi, fit.nsF.cF.MSDi)
nsT.theo.MSDi = c(nsT.theo.MSDi, fit.nsT.cF.MSDi)
nsF.theo.MSDi.s = c(nsF.theo.MSDi.s, fit.nsF.cF.MSDi.s)
nsT.theo.MSDi.s = c(nsT.theo.MSDi.s, fit.nsT.cF.MSDi.s)
cF.exp.MSDi = cF.exp.MSDi[!is.na(cF.exp.MSDi)]
cF.exp.MSDi.s = cF.exp.MSDi.s[!is.na(cF.exp.MSDi.s)]
exp.MSDi = c(exp.MSDi, cF.exp.MSDi)
exp.MSDi.s = c(exp.MSDi.s, cF.exp.MSDi.s)
}
# Caluclate measures.
R2.nsF.cF = cor(nsF.theo.MSDi, exp.MSDi) ^ 2
R2.nsT.cF = cor(nsT.theo.MSDi, exp.MSDi) ^ 2
R2.nsF.cF.s = cor(nsF.theo.MSDi.s, exp.MSDi.s) ^ 2
R2.nsT.cF.s = cor(nsT.theo.MSDi.s, exp.MSDi.s) ^ 2
MSE.nsF.cF = mean((nsF.theo.MSDi - exp.MSDi) ^ 2)
MSE.nsT.cF = mean((nsT.theo.MSDi - exp.MSDi) ^ 2)
MSE.nsF.cF.s = mean((nsF.theo.MSDi.s - exp.MSDi.s) ^ 2)
MSE.nsT.cF.s = mean((nsT.theo.MSDi.s - exp.MSDi.s) ^ 2)
# Chunk 3
layout(matrix(1:3, 3, 1, byrow = F))
plot(nsF.theo.MSDi, type = "l", xlab = "sitio", ylab = "Theoretical")
plot(exp.MSDi, type = "l", col = "red", ylab = "Experimental")
plot(nsF.theo.MSDi, type = "l", ylab = "both")
points(exp.MSDi, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsF.cF, digits = 2)), bty = "n", text.col = "red")
# Chunk 4
layout(matrix(1:3, 3, 1, byrow = F))
plot(nsT.theo.MSDi, type="l", xlab = "sitio", ylab = "Theoretical")
plot(exp.MSDi, type="l", col ="red", ylab = "Experimental")
plot(nsT.theo.MSDi, type="l", ylab = "both")
points(exp.MSDi, col = "red", type="l")
legend("topleft", paste("R^2", round(R2.nsT.cF, digits = 2)), bty = "n", text.col = "red")
getwd()
setwd(getwd())
# Directories.
out.dir <- "OUT"
nsF.theo.MSDi.s = c()
exp.MSDi.s = c()
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
input
}
# Chunk 1: setup
knitr::opts_chunk$set(warning = FALSE, echo = FALSE, message = FALSE)
# Chunk 2
# Directories.
out.dir <- "OUT"
nsF.theo.MSDi.s = c()
exp.MSDi.s = c()
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Print the input in the html file.
print(input)
# Start a loop to read data for each family.
for (a in (1:nrow(input))) {
family <- as.character(input$family)[a]
mut.model = input$mut.model[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
#Read experimental data.
analysis.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", "FALSE", "_R0_", R0, "_core_", "FALSE", "_K.analysis_", K.analysis, sep = "")
m.cF.exp.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.dr.squarei.csv", sep = "")))
cF.exp.MSDi.s = colMeans(m.cF.exp.smooth.dr.squarei, na.rm = T )
#Read theoretical data#
m.nsF.cF.theo.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.dr.squarei.csv", sep = "")))
nsF.cF.theo.MSDi.s = colMeans(m.nsF.cF.theo.smooth.dr.squarei, na.rm = T)
## Fit theoretical data with experimental data.
fit.nsF.cF.s = lm(cF.exp.MSDi.s ~ nsF.cF.theo.MSDi.s)
fit.nsF.cF.MSDi.s = fitted.values(fit.nsF.cF.s)
# Concatenate information.
nsF.theo.MSDi.s = c(nsF.theo.MSDi.s, fit.nsF.cF.MSDi.s)
cF.exp.MSDi.s = cF.exp.MSDi.s[!is.na(cF.exp.MSDi.s)]
exp.MSDi.s = c(exp.MSDi.s, cF.exp.MSDi.s)
}
# Caluclate measures.
R2.nsF.cF.s = cor(nsF.theo.MSDi.s, exp.MSDi.s) ^ 2
MSE.nsF.cF.s = mean((nsF.theo.MSDi.s - exp.MSDi.s) ^ 2)
# Chunk 3
plot(nsF.theo.MSDi.s, type = "l", xlab = "site", ylab = "Theoretical NS = F", ylim = c(0, 0.14))
# Chunk 4
plot(exp.MSDi.s, type = "l", col = "red", xlab = "site",  ylab = "Experimental", ylim = c(0, 0.14))
# Chunk 5
plot(nsF.theo.MSDi.s, type = "l", xlab = "site", ylab = "Merge", ylim = c(0, 0.14))
points(exp.MSDi.s, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsF.cF.s, digits = 2), " ", "MSE", signif(MSE.nsF.cF.s, digits = 4)), bty = "n", text.col = "red")
plot(nsF.theo.MSDi.s, type = "l", xlab = "site", ylab = "Theoretical NS = F", ylim = c(0, 0.14))
plot(exp.MSDi.s, type = "l", col = "red", xlab = "site",  ylab = "Experimental", ylim = c(0, 0.14))
plot(nsF.theo.MSDi.s, type = "l", xlab = "site", ylab = "Merge", ylim = c(0, 0.14))
points(exp.MSDi.s, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsF.cF.s, digits = 2), " ", "MSE", signif(MSE.nsF.cF.s, digits = 4)), bty = "n", text.col = "red")
setwd(getwd())
input.fname <- file.path(C:\Users\Usuario\Desktop\VariabilidadEstructuralProteica,"input_MainMultipleReport.csv")
input.fname <- file.path("input_MainMultipleReport.csv")
input.fname
input <- read.csv(input.fname)
input
getwd()
setwd(getwd())
# Chunk 1: setup
knitr::opts_chunk$set(warning = FALSE, echo = FALSE, message = FALSE)
# Chunk 2
# Directories.
out.dir <- "OUT"
# Create matrixes.
nsF.theo.MSDi = c()
nsT.theo.MSDi = c()
nsF.theo.MSDi.s = c()
nsT.theo.MSDi.s = c()
exp.MSDi = c()
exp.MSDi.s = c()
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Print the input in the html file.
print(input)
# Start a loop to read data for each family.
for (a in (1:nrow(input))) {
family <- as.character(input$family)[a]
mut.model = input$mut.model[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
#Read experimental data.
analysis.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", "FALSE", "_R0_", R0, "_core_", "FALSE", "_K.analysis_", K.analysis, sep = "")
m.cF.exp.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.dr.squarei.csv", sep = "")))
m.cF.exp.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.dr.squarei.csv", sep = "")))
cF.exp.MSDi = colMeans(m.cF.exp.dr.squarei, na.rm = T )
cF.exp.MSDi.s = colMeans(m.cF.exp.smooth.dr.squarei, na.rm = T )
#Read theoretical data#
# natural selection (ns) = F.
m.nsF.cF.theo.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.dr.squarei.csv", sep = "")))
m.nsF.cF.theo.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.dr.squarei.csv", sep = "")))
nsF.cF.theo.MSDi = colMeans(m.nsF.cF.theo.dr.squarei, na.rm = T)
nsF.cF.theo.MSDi.s = colMeans(m.nsF.cF.theo.smooth.dr.squarei, na.rm = T)
# natural selection (ns) = T.
analysis.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", "TRUE", "_R0_", R0, "_core_", "FALSE", "_K.analysis_", K.analysis, sep = "")
m.nsT.cF.theo.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.dr.squarei.csv", sep = "")))
m.nsT.cF.theo.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.dr.squarei.csv", sep = "")))
nsT.cF.theo.MSDi = colMeans(m.nsT.cF.theo.dr.squarei, na.rm = T)
nsT.cF.theo.MSDi.s = colMeans(m.nsT.cF.theo.smooth.dr.squarei, na.rm = T)
## Fit theoretical data with experimental data.
fit.nsF.cF = lm(cF.exp.MSDi ~ nsF.cF.theo.MSDi)
fit.nsF.cF.MSDi = fitted.values(fit.nsF.cF)
fit.nsT.cF = lm(cF.exp.MSDi ~ nsT.cF.theo.MSDi)
fit.nsT.cF.MSDi = fitted.values(fit.nsT.cF)
fit.nsF.cF.s = lm(cF.exp.MSDi.s ~ nsF.cF.theo.MSDi.s)
fit.nsF.cF.MSDi.s = fitted.values(fit.nsF.cF.s)
fit.nsT.cF.s = lm(cF.exp.MSDi.s ~ nsT.cF.theo.MSDi.s)
fit.nsT.cF.MSDi.s = fitted.values(fit.nsT.cF.s)
# Concatenate information.
nsF.theo.MSDi = c(nsF.theo.MSDi, fit.nsF.cF.MSDi)
nsT.theo.MSDi = c(nsT.theo.MSDi, fit.nsT.cF.MSDi)
nsF.theo.MSDi.s = c(nsF.theo.MSDi.s, fit.nsF.cF.MSDi.s)
nsT.theo.MSDi.s = c(nsT.theo.MSDi.s, fit.nsT.cF.MSDi.s)
cF.exp.MSDi = cF.exp.MSDi[!is.na(cF.exp.MSDi)]
cF.exp.MSDi.s = cF.exp.MSDi.s[!is.na(cF.exp.MSDi.s)]
exp.MSDi = c(exp.MSDi, cF.exp.MSDi)
exp.MSDi.s = c(exp.MSDi.s, cF.exp.MSDi.s)
}
# Caluclate measures.
R2.nsF.cF = cor(nsF.theo.MSDi, exp.MSDi) ^ 2
R2.nsT.cF = cor(nsT.theo.MSDi, exp.MSDi) ^ 2
R2.nsF.cF.s = cor(nsF.theo.MSDi.s, exp.MSDi.s) ^ 2
R2.nsT.cF.s = cor(nsT.theo.MSDi.s, exp.MSDi.s) ^ 2
MSE.nsF.cF = mean((nsF.theo.MSDi - exp.MSDi) ^ 2)
MSE.nsT.cF = mean((nsT.theo.MSDi - exp.MSDi) ^ 2)
MSE.nsF.cF.s = mean((nsF.theo.MSDi.s - exp.MSDi.s) ^ 2)
MSE.nsT.cF.s = mean((nsT.theo.MSDi.s - exp.MSDi.s) ^ 2)
# Chunk 3
layout(matrix(1:3, 3, 1, byrow = F))
plot(nsF.theo.MSDi, type = "l", xlab = "sitio", ylab = "Theoretical")
plot(exp.MSDi, type = "l", col = "red", ylab = "Experimental")
plot(nsF.theo.MSDi, type = "l", ylab = "both")
points(exp.MSDi, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsF.cF, digits = 2)), bty = "n", text.col = "red")
# Chunk 4
layout(matrix(1:3, 3, 1, byrow = F))
plot(nsT.theo.MSDi, type="l", xlab = "sitio", ylab = "Theoretical")
plot(exp.MSDi, type="l", col ="red", ylab = "Experimental")
plot(nsT.theo.MSDi, type="l", ylab = "both")
points(exp.MSDi, col = "red", type="l")
legend("topleft", paste("R^2", round(R2.nsT.cF, digits = 2)), bty = "n", text.col = "red")
# Chunk 5
plot(nsF.theo.MSDi.s, type = "l", xlab = "site", ylab = "Theoretical NS = F", ylim = c(0, 0.14))
# Chunk 6
plot(exp.MSDi.s, type = "l", col = "red", xlab = "site",  ylab = "Experimental", ylim = c(0, 0.14))
# Chunk 7
plot(nsF.theo.MSDi.s, type = "l", xlab = "site", ylab = "Merge", ylim = c(0, 0.14))
points(exp.MSDi.s, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsF.cF.s, digits = 2), " ", "MSE", signif(MSE.nsF.cF.s, digits = 4)), bty = "n", text.col = "red")
# Chunk 8
plot(nsT.theo.MSDi.s, type="l", xlab = "sitie", ylab = "Theoretical NS = T", ylim = c(0, 0.14))
# Chunk 9
plot(exp.MSDi.s, type = "l", col = "red"xlab = "sitie",, ylab = "Experimental", ylim = c(0, 0.14))
# Chunk 10
plot(nsT.theo.MSDi.s, type = "l"xlab = "sitie",, ylab = "Merge", ylim = c(0, 0.14))
points(exp.MSDi.s, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsT.cF.s, digits = 2), " ", "MSE", signif(MSE.nsT.cF.s, digits = 2)), bty = "n", text.col = "red")
# Chunk 1: setup
knitr::opts_chunk$set(warning = FALSE, echo = FALSE, message = FALSE)
# Chunk 2
# Directories.
out.dir <- "OUT"
# Create matrixes.
nsF.theo.MSDi = c()
nsT.theo.MSDi = c()
nsF.theo.MSDi.s = c()
nsT.theo.MSDi.s = c()
exp.MSDi = c()
exp.MSDi.s = c()
# Read input.
input.fname <- file.path("input_MainMultipleReport.csv")
input <- read.csv(input.fname)
# Print the input in the html file.
print(input)
# Start a loop to read data for each family.
for (a in (1:nrow(input))) {
family <- as.character(input$family)[a]
mut.model = input$mut.model[a]
R0 = input$R0[a]
K.analysis = input$K.analysis[a]
#Read experimental data.
analysis.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", "FALSE", "_R0_", R0, "_core_", "FALSE", "_K.analysis_", K.analysis, sep = "")
m.cF.exp.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.dr.squarei.csv", sep = "")))
m.cF.exp.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.exp.smooth.dr.squarei.csv", sep = "")))
cF.exp.MSDi = colMeans(m.cF.exp.dr.squarei, na.rm = T )
cF.exp.MSDi.s = colMeans(m.cF.exp.smooth.dr.squarei, na.rm = T )
#Read theoretical data#
# natural selection (ns) = F.
m.nsF.cF.theo.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.dr.squarei.csv", sep = "")))
m.nsF.cF.theo.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.dr.squarei.csv", sep = "")))
nsF.cF.theo.MSDi = colMeans(m.nsF.cF.theo.dr.squarei, na.rm = T)
nsF.cF.theo.MSDi.s = colMeans(m.nsF.cF.theo.smooth.dr.squarei, na.rm = T)
# natural selection (ns) = T.
analysis.fname.id <- paste(family, "_mut.model_", mut.model, "_naturalSelection_", "TRUE", "_R0_", R0, "_core_", "FALSE", "_K.analysis_", K.analysis, sep = "")
m.nsT.cF.theo.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.dr.squarei.csv", sep = "")))
m.nsT.cF.theo.smooth.dr.squarei = read.csv(file.path(out.dir, paste(analysis.fname.id, "_out_m.theo.smooth.dr.squarei.csv", sep = "")))
nsT.cF.theo.MSDi = colMeans(m.nsT.cF.theo.dr.squarei, na.rm = T)
nsT.cF.theo.MSDi.s = colMeans(m.nsT.cF.theo.smooth.dr.squarei, na.rm = T)
## Fit theoretical data with experimental data.
fit.nsF.cF = lm(cF.exp.MSDi ~ nsF.cF.theo.MSDi)
fit.nsF.cF.MSDi = fitted.values(fit.nsF.cF)
fit.nsT.cF = lm(cF.exp.MSDi ~ nsT.cF.theo.MSDi)
fit.nsT.cF.MSDi = fitted.values(fit.nsT.cF)
fit.nsF.cF.s = lm(cF.exp.MSDi.s ~ nsF.cF.theo.MSDi.s)
fit.nsF.cF.MSDi.s = fitted.values(fit.nsF.cF.s)
fit.nsT.cF.s = lm(cF.exp.MSDi.s ~ nsT.cF.theo.MSDi.s)
fit.nsT.cF.MSDi.s = fitted.values(fit.nsT.cF.s)
# Concatenate information.
nsF.theo.MSDi = c(nsF.theo.MSDi, fit.nsF.cF.MSDi)
nsT.theo.MSDi = c(nsT.theo.MSDi, fit.nsT.cF.MSDi)
nsF.theo.MSDi.s = c(nsF.theo.MSDi.s, fit.nsF.cF.MSDi.s)
nsT.theo.MSDi.s = c(nsT.theo.MSDi.s, fit.nsT.cF.MSDi.s)
cF.exp.MSDi = cF.exp.MSDi[!is.na(cF.exp.MSDi)]
cF.exp.MSDi.s = cF.exp.MSDi.s[!is.na(cF.exp.MSDi.s)]
exp.MSDi = c(exp.MSDi, cF.exp.MSDi)
exp.MSDi.s = c(exp.MSDi.s, cF.exp.MSDi.s)
}
# Caluclate measures.
R2.nsF.cF = cor(nsF.theo.MSDi, exp.MSDi) ^ 2
R2.nsT.cF = cor(nsT.theo.MSDi, exp.MSDi) ^ 2
R2.nsF.cF.s = cor(nsF.theo.MSDi.s, exp.MSDi.s) ^ 2
R2.nsT.cF.s = cor(nsT.theo.MSDi.s, exp.MSDi.s) ^ 2
MSE.nsF.cF = mean((nsF.theo.MSDi - exp.MSDi) ^ 2)
MSE.nsT.cF = mean((nsT.theo.MSDi - exp.MSDi) ^ 2)
MSE.nsF.cF.s = mean((nsF.theo.MSDi.s - exp.MSDi.s) ^ 2)
MSE.nsT.cF.s = mean((nsT.theo.MSDi.s - exp.MSDi.s) ^ 2)
# Chunk 3
layout(matrix(1:3, 3, 1, byrow = F))
plot(nsF.theo.MSDi, type = "l", xlab = "sitio", ylab = "Theoretical")
plot(exp.MSDi, type = "l", col = "red", ylab = "Experimental")
plot(nsF.theo.MSDi, type = "l", ylab = "both")
points(exp.MSDi, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsF.cF, digits = 2)), bty = "n", text.col = "red")
# Chunk 4
layout(matrix(1:3, 3, 1, byrow = F))
plot(nsT.theo.MSDi, type="l", xlab = "sitio", ylab = "Theoretical")
plot(exp.MSDi, type="l", col ="red", ylab = "Experimental")
plot(nsT.theo.MSDi, type="l", ylab = "both")
points(exp.MSDi, col = "red", type="l")
legend("topleft", paste("R^2", round(R2.nsT.cF, digits = 2)), bty = "n", text.col = "red")
# Chunk 5
plot(nsF.theo.MSDi.s, type = "l", xlab = "site", ylab = "Theoretical NS = F", ylim = c(0, 0.14))
# Chunk 6
plot(exp.MSDi.s, type = "l", col = "red", xlab = "site",  ylab = "Experimental", ylim = c(0, 0.14))
# Chunk 7
plot(nsF.theo.MSDi.s, type = "l", xlab = "site", ylab = "Merge", ylim = c(0, 0.14))
points(exp.MSDi.s, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsF.cF.s, digits = 2), " ", "MSE", signif(MSE.nsF.cF.s, digits = 4)), bty = "n", text.col = "red")
# Chunk 8
plot(nsT.theo.MSDi.s, type="l", xlab = "sitie", ylab = "Theoretical NS = T", ylim = c(0, 0.14))
# Chunk 9
plot(exp.MSDi.s, type = "l", col = "red", xlab = "sitie", ylab = "Experimental", ylim = c(0, 0.14))
# Chunk 10
plot(nsT.theo.MSDi.s, type = "l", xlab = "sitie", ylab = "Merge", ylim = c(0, 0.14))
points(exp.MSDi.s, col = "red", type = "l")
legend("topleft", paste("R^2", round(R2.nsT.cF.s, digits = 2), " ", "MSE", signif(MSE.nsT.cF.s, digits = 2)), bty = "n", text.col = "red")
