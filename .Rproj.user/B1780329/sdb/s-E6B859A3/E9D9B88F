{
    "contents" : "---\ntitle: \"Comparaciones Teórico-Experimental\"\noutput: html_document\n---\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(warning=FALSE,echo=FALSE,message=FALSE)\n```\n\n```{r}\n# INFORMACIÓN\n#\n# Este programa genera un archivo HTLM comparando la divergencia etsructural de\n# proteínas experimentales y mutantes teóricas.\n# Para correrlo se debe completar un Input (\"DATA/comp_input.csv\") especificando:\n# -family: la familia de proteínas a comparar, debe estar escrita consistentemente \n# con los archivos theoretical_input y experimental_input.\n# -p.ref: la proteína dereferencia de la familia, que debe ser escrita \n# consisntentemente con el archivo experimental_input, es decir que debe ser escrita de la \n# forma en la que está escrita en el dataset.\n# -heme: solo se utiliza para la familia de las globinas, puede ser \"TRUE\" o \n# \"FALSE\" dependiendo de si se quiere considerar o no al grupo HEMO. \n# -index: el índice de las proteínas de la familia que se desea analizar.\n# Remove objects.\nrm (list=ls())\n# Read Input.\ninput <- read.csv(\"DATA/comp_input.csv\")\nfamily <- input$family[1]\np.ref <- input$p.ref[1]\nheme <- input$heme[1]\nindex = as.vector(input$index)\n# Nmodes to analyze.\nnmodes1 = 10 \nnmodes2 = 25\nnmodes3 = 50\nnmodes4 = 100\n# Load librarys. \nlibrary(flux)  # function \"auc\".\n# Source functions.\nsource(\"FUNCTIONS/CalculateGroupsMeansQuantiles.R\")\n# Read files and calculate measures.\n# Experimental.\ndir.e <- \"OUT/Experimental\"\npdbid <- read.csv(file.path(\"DATA/Experimental\", paste(family, \"_dataset.csv\", sep = \"\")))$pdbid\npdbid <- pdbid[pdbid != as.character(p.ref)]\nif (as.character(family) == \"globins\"){\n  family <- paste(family, \"_heme_\", heme, sep = \"\")\n}\nm.Pne = read.csv(file.path(dir.e, paste(family, \"_out_m.Pn.csv\", sep = \"\")))[index, 1:nmodes4]\nPne.mean = colMeans(m.Pne)\nm.Qne = t(apply(m.Pne, 1, cumsum))\nQne.mean = colMeans(m.Qne)\nm.evaluese = read.csv(file.path(dir.e, paste(family, \"_out_m.evalues.csv\", sep = \"\")))[index, 1:nmodes4]\nevaluese = colMeans(m.evaluese)\nievaluese = 1/evaluese\nlaligned = read.csv(file.path(dir.e, paste(family, \"_out_m.laligned.csv\", sep = \"\")))$x\nMSD = read.csv(file.path(dir.e, paste(family, \"_out_MSD.csv\", sep = \"\")))$x\nid = read.csv(file.path(dir.e, paste(family, \"_out_m.ID.csv\", sep = \"\")))$x\nid.index = id[index]\n# Theoretical.\ndir.t <- \"OUT/Theoretical\"\nm.Pnt = read.csv(file.path(dir.t, paste(family, \"_out_m.Pn.csv\", sep = \"\")))[, 1:nmodes4]\nm.Qnt = t(apply(m.Pnt, 1, cumsum))\nevalues = read.csv(file.path(dir.t, paste(family, \"_out_evalues.csv\", sep = \"\")))$x[1:nmodes4]\nievalues = 1/evalues\n# Number of t and e proteins.\nnmut = nrow(m.Pnt)\nnexp = length(index)\n# Number of t groups.\nngroups = as.integer(nmut / nexp)\n```\n\nConjunto teórico: `r nmut` mutantes de `r p.ref` de `r round(mean(id.index))` % de identidad secuencial con ANM R0 = 12 y Fmax = 2. Se seleccionó esta proteína ya que es la que presenta menor MSD con respecto a las coordenadas xyz promedio de todas las proteínas del conjunto experimental. El porcentaje de mutaciones se seleccionó de acuerdo al promedio de identidad secuencial de proteínas del conjunto experimental. \n\nConjunto experimental: `r nexp` proteínas de la familia de `r family`.Las proteínas tienen un promedio de identidad secuencial de `r round(mean(id.index))`%. Todas las proteínas del sub-conjunto elegidas alinean en todos los sitios de `r p.ref`, o en como máximo 1 sitio menos.\n```{r}\n# Analysis experimental dataset.\nlayout(matrix(1:4, 2, 2, byrow = T))\nhist(id, main = \"%ID con referencia\", col = \"grey\")\nhist(laligned, main = \"Número de sitios alineados con referencia\", col = \"grey\")\nhist(MSD, main = \"MSD con la referencia\", col = \"grey\")\nplot(id, MSD, xlab = \"%ID\", main = \"MSD vs. %ID\")\ncaract <- data.frame(pdbid, id, laligned, MSD)\ncaract\n```\n\n\n```{r}\n# Calculate rho.\nrho.t.1 <- matrix(0, nrow = nmut, ncol = 1)\nrho.t.2 <- matrix(0, nrow = nmut, ncol = 1)\nrho.t.3 <- matrix(0, nrow = nmut, ncol = 1)\nrho.t.4 <- matrix(0, nrow = nmut, ncol = 1)\nfor (i in (1:nmut)) {\n  rho.t.1[i, ] <- cor((as.vector(as.matrix(m.Pnt[i, 1:nmodes1])) * evalues[1:nmodes1]), ievalues[1:nmodes1], method = \"pearson\")\t\n  rho.t.2[i, ] <- cor((as.vector(as.matrix(m.Pnt[i, 1:nmodes2])) * evalues[1:nmodes2]), ievalues[1:nmodes2], method = \"pearson\")\t\n  rho.t.3[i, ] <- cor((as.vector(as.matrix(m.Pnt[i, 1:nmodes3])) * evalues[1:nmodes3]), ievalues[1:nmodes3], method = \"pearson\")\t\n  rho.t.4[i, ] <- cor((as.vector(as.matrix(m.Pnt[i, 1:nmodes4])) * evalues[1:nmodes4]), ievalues[1:nmodes4], method = \"pearson\")\t   \n}\nrho.e.1 <- matrix(0, nrow = nexp, ncol = 1)\nrho.e.2 <- matrix(0, nrow = nexp, ncol = 1)\nrho.e.3 <- matrix(0, nrow = nexp, ncol = 1) \nrho.e.4 <- matrix(0, nrow = nexp, ncol = 1) \nfor (i in (1:nexp)) {\n  rho.e.1[i, ] <- cor((as.vector(as.matrix(m.Pne[i, 1:nmodes1])) * evaluese[1:nmodes1]), ievaluese[1:nmodes1], method = \"pearson\")\n  rho.e.2[i, ] <- cor((as.vector(as.matrix(m.Pne[i, 1:nmodes2])) * evaluese[1:nmodes2]), ievaluese[1:nmodes2], method = \"pearson\")\n  rho.e.3[i, ] <- cor((as.vector(as.matrix(m.Pne[i, 1:nmodes3])) * evaluese[1:nmodes3]), ievaluese[1:nmodes3], method = \"pearson\")\n  rho.e.4[i, ] <- cor((as.vector(as.matrix(m.Pne[i, 1:nmodes4])) * evaluese[1:nmodes4]), ievaluese[1:nmodes4], method = \"pearson\")\n}\n# Calculate auc.\nauc.t.1 <- matrix(0, nrow = nmut, ncol = 1)\nauc.t.2 <- matrix(0, nrow = nmut, ncol = 1)\nauc.t.3 <- matrix(0, nrow = nmut, ncol = 1)\nauc.t.4 <- matrix(0, nrow = nmut, ncol = 1)\nfor (i in (1:nmut)) {\n  auc.t.1[i, ] <- auc(seq(1:nmodes1), m.Qnt[i,1:nmodes1])\n  auc.t.2[i, ] <- auc(seq(1:nmodes2), m.Qnt[i,1:nmodes2])\n  auc.t.3[i, ] <- auc(seq(1:nmodes3), m.Qnt[i,1:nmodes3])\n  auc.t.4[i, ] <- auc(seq(1:nmodes4), m.Qnt[i,1:nmodes4])\n}\nauc.e.1 <- matrix(0, nrow = nexp, ncol = 1)\nauc.e.2 <- matrix(0, nrow = nexp, ncol = 1)\nauc.e.3 <- matrix(0, nrow = nexp, ncol = 1)\nauc.e.4 <- matrix(0, nrow = nexp, ncol = 1)\nfor (i in (1:nexp)) {\n  auc.e.1[i, ] <- auc(seq(1:nmodes1), m.Qne[i, 1:nmodes1])\n  auc.e.2[i, ] <- auc(seq(1:nmodes2), m.Qne[i, 1:nmodes2])\n  auc.e.3[i, ] <- auc(seq(1:nmodes3), m.Qne[i, 1:nmodes3])\n  auc.e.4[i, ] <- auc(seq(1:nmodes4), m.Qne[i, 1:nmodes4])\n}\n``` \n\nLas distribuciones de auc y rho para cada conjunto se muestran a continuación (azul= teórico, rojo = experimental)\n\n```{r}\nlayout(matrix(1:4, 2, 2, byrow = T))\nplot(density(rho.t.1), col = \"blue\", ylab = \"Frecuencia\", xlab = \"rho\", main = \"Histograma rho 10 modos\")\npoints(x = c(rho.e.1), y = rep(0, nexp), col = \"red\")\nplot(density(auc.t.1), col = \"blue\", ylab = \"Frecuencia\", xlab = \"auc\", main = \"Histograma auc 10 modos\")\npoints(x = c(auc.e.1), y = rep(0, nexp), col = \"red\")\nplot(density(rho.t.2), col = \"blue\", ylab = \"Frecuencia\", xlab = \"rho\", main = \"Histograma rho 25 modos\")\npoints(x = c(rho.e.2), y = rep(0, nexp), col = \"red\")\nplot(density(auc.t.2), col = \"blue\", ylab = \"Frecuencia\", xlab = \"auc\", main = \"Histograma auc 25 modos\")\npoints(x = c(auc.e.2), y = rep(0, nexp), col = \"red\")\n```\n\n```{r}\nlayout(matrix(1:4, 2, 2, byrow = T))\nplot(density(rho.t.3), col = \"blue\", ylab = \"Frecuencia\", xlab = \"rho\", main = \"Histograma rho 50 modos\")\npoints(x = c(rho.e.3), y = rep(0, nexp), col = \"red\")\nplot(density(auc.t.3), col = \"blue\", ylab = \"Frecuencia\", xlab = \"auc\", main = \"Histograma auc 50 modos\")\npoints(x = c(auc.e.3), y = rep(0, nexp), col = \"red\")\nplot(density(rho.t.4), col = \"blue\", ylab = \"Frecuencia\", xlab = \"rho\", main = \"Histograma rho 100 modos\")\npoints(x = c(rho.e.4), y = rep(0, nexp), col = \"red\")\nplot(density(auc.t.4), col = \"blue\", ylab = \"Frecuencia\", xlab = \"auc\", main = \"Histograma auc 100 nmodos\")\npoints(x = c(auc.e.4), y = rep(0, nexp), col = \"red\")\n```\n\nLas distribuciones de Pn y Qn de los conjuntos son las siguientes:\n\n```{r}\n\n# Calculate groups, means and quantiles.\nPntgroup <- CalculateGroupsMeansQuantiles(m.Pnt, ngroups, nexp)\nm.Pntgroup <- Pntgroup$mean.group\nPntgroup.mean <- Pntgroup$mean.total\nPntgroup.quantile5 <- Pntgroup$quantile[1, ]\nPntgroup.quantile95 <- Pntgroup$quantile[2, ] \nQntgroup <- CalculateGroupsMeansQuantiles(m.Qnt, ngroups, nexp)\nm.Qntgroup <- Qntgroup$mean.group\nQntgroup.mean <- Qntgroup$mean.total\nQntgroup.quantile5 <- Qntgroup$quantile[1, ]\nQntgroup.quantile95 <- Qntgroup$quantile[2, ]\n# Graphics.\nlayout(matrix(1:2, 1, 2, byrow = T))\nplot(Pntgroup.mean, ylab = \"Pn promedio\", xlab = \"nmodo\", type = \"l\", ylim = c(0, 0.07), main = \"Pn promedio vs. nmodo\")\nlines(Pntgroup.quantile5, col = \"green\")\nlines(Pntgroup.quantile95, col = \"green\")\npoints(Pne.mean, col = \"red\")\nplot(Qntgroup.mean, ylab = \"Qn promedio\", xlab = \"nmodo\", type = \"l\", ylim = c(0, 0.7), main = \"Qn promedio vs. nmodo\")\nlines(Qntgroup.quantile5, col = \"green\")\nlines(Qntgroup.quantile95, col = \"green\")\npoints(Qne.mean, col = \"red\")\n```\n\nNegro: Teorico\nRojo: Experimental\nVerdes: cuartiles 0.05 y 0.95 de `r ngroups` grupos de `r nexp` mutantes teóricas\n\n\n\n",
    "created" : 1445188548293.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3743886160",
    "id" : "E9D9B88F",
    "lastKnownWriteTime" : 1445207675,
    "path" : "C:/Users/Laurita/Desktop/Doctorado/VariabilidadEstructuralProteica/ComparisonsMain.Rmd",
    "project_path" : "ComparisonsMain.Rmd",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_markdown"
}