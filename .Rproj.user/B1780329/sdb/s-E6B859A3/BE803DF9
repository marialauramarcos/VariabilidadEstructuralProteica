{
    "contents" : "# INFORMACIÓN:\n#\n# El programa calcula medidas de variabilidad estructural y dinámica de alineamientos múltiples de \n# familias de proteínas provenientes de la base de datos de alineamientos múltiples \"Homstrad\".\n#\n# Para utilizar el programa se debe completar un input (\"DATA/Experimental/experimental_input.csv\") especificando: \n# -family:la familia de proteínas del alineamiento, que puede ser \"serinProteases\", \"globins\" o \"plastocyanins\"\n# -p.ref: la proteína de referncia que se desee utilizar, teniendo en cuenta que la misma debe ser escrita de \n# la misma forma en la que se encuentra en el dataset de la familia correspondiente \n# (ej:\"DATA/Experimental/serinProteases_dataset.csv\").\n# -heme: solo se utiliza para la familia de las globinas, puede ser \"TRUE\" o \"FALSE\", dependiendo de si \n# se desea o no considerar al grupo HEMO. \n# -model: el modelo de red elástica a usar, que solo puede ser \"ANM\" por el momento.\n# -R0: cut-off del ANM.\n# -core: puede ser \"TRUE\" o \"FALSE\" dependiendo de si se quiere analizar solo los sectores\n# del alineamiento donde no hay gaps. \n\n# Remove objects.\nrm(list = ls())\n\n# Data.dir.\ndata.dir <- \"DATA/Experimental\"\n\n# Read input.\ninput.fname <- file.path(data.dir, \"experimental_input.csv\")\ninput <- read.csv(input.fname)\nfamily <- as.character(input$family) \np.ref <- as.character(input$p.ref) \nheme <- as.character(input$heme)  \nmodel <- input$model  \nR0 = input$R0  \ncore = input$core  \n\n# Data fnames.\nalignment.fname <- file.path(data.dir, paste(family, \"_alignment.txt\", sep = \"\"))  \npdbs.fname <- file.path(data.dir, paste(family, \"_coordinates.pdb\", sep = \"\")) \ndataset.fname <- file.path(data.dir, paste(family, \"_dataset.csv\", sep = \"\"))  \n\n# Functions fnames.\nReadCA.fname <- \"FUNCTIONS/ReadCA.R\" \nReadHeme.fname <- \"FUNCTIONS/ReadHeme.R\"  \nAnalyzeAlignmentGeneral.fname <- \"FUNCTIONS/AnalyzeAlignmentGeneral.R\" \nCalculateID.fname <- \"FUNCTIONS/CalculateID.R\" \nCalculateKeff.fname <- \"FUNCTIONS/CalculateKeff.R\"  \nCalculateK.fname <- \"FUNCTIONS/CalculateK.R\"  \nCalculateKij.fname <- file.path(\"FUNCTIONS\", paste(\"CalculateKij\", model, \".R\", sep = \"\")) \nCalculateVariability.fname <- \"FUNCTIONS/CalculateVariability.R\" \n\n# Output dir.\nout.dir <- \"OUT/Experimental\"\n\n# General parameters.\nTOLERANCE = 1e-10 \n\n# Load Librarys.\nlibrary(seqinr) \nlibrary(bio3d) \n\n# Source Functions.\nsource(ReadCA.fname) \nsource(ReadHeme.fname) \nsource(AnalyzeAlignmentGeneral.fname)\nsource(CalculateID.fname)\nsource(CalculateKij.fname)\nsource(CalculateK.fname)\nsource(CalculateKeff.fname)\nsource(CalculateVariability.fname)\n\n# Read dataset.\ndataset <- read.csv(dataset.fname)\npdbid <- as.character(dataset$pdbid) \nchain <- as.character(dataset$chain)\nnprot = length(pdbid)\n\n# Read PDB of p.ref.\nchain.p.ref <- chain[pdbid == p.ref]\npdb.p.ref <- ReadCA(pdbs.fname, chain.p.ref)\nr.p.ref = pdb.p.ref$xyz.calpha\nnaa.p.ref = pdb.p.ref$nsites\n\n# Read alignment.\nalignment.id <- read.fasta(alignment.fname)\nalignment <- alignment.id$ali[, -ncol(alignment.id$ali)]  # The last column is \"*\".\nid <- alignment.id$id\n\n# Measures of variability.\nm.laligned = matrix(ncol = 1, nrow = nprot)\nm.ID = matrix(ncol = 1, nrow = nprot)\nm.nH = matrix(ncol = 3 * naa.p.ref, nrow = nprot)\nm.Pn = matrix(ncol = 3 * naa.p.ref, nrow = nprot)\nm.evalues = matrix(ncol = 3 * naa.p.ref, nrow = nprot)\nm.d.evalues = matrix(ncol = 3 * naa.p.ref, nrow = nprot)\nm.dr.squarei = matrix(ncol = naa.p.ref, nrow = nprot)\n\nfor (P in (1:nprot)) {\n  \n  # Create a data frame to analyze the alignment.\n\tdf.alignment <- list(\"alignment\" = alignment,\n\t                            \"id\" = id,   \n\t                           \"p.1\" = p.ref,\n\t                           \"p.2\" = pdbid[P])\n\tif (core == \"TRUE\"){\n\t  class(df.alignment) <- \"Core\"\n\t} else {\n\t  class(df.alignment) <- \"NoCore\"\n\t}\n\t\n\t# Anylize alignment.\n\ta.alignment <- AnalyzeAlignmentGeneral(df.alignment)\n\taligned.p.ref.index <- a.alignment$aligned.p.1.index\n\taligned.p.2.index <- a.alignment$aligned.p.2.index\n\tnot.aligned.p.ref.index <- a.alignment$not.aligned.p.1.index\n\tnot.aligned.p.2.index <- a.alignment$not.aligned.p.2.index\n\tnaligned <- a.alignment$naligned\n  \n  # Read PDB of p.2.  \n  chain.p.2 <- chain[[P]]\n  pdb.p.2 <- ReadCA(pdbs.fname, chain.p.2)\n  r.p.2 <- pdb.p.2$xyz.calpha\n  naa.p.2 <- pdb.p.2$nsites\n  \n  # Calculate r.heme and add to r and to not.aligned.index.\n\tif (family == \"globins\" & heme == \"TRUE\") {\n\t  if (P == 1) {\n\t    r.heme.p.ref = ReadHeme(pdbs.fname, chain.p.ref)\n\t    r.p.ref = cbind(r.p.ref, r.heme.p.ref)\n\t    nsites.p.ref = ncol(r.p.ref)\n\t  }\n\t  not.aligned.p.ref.index <- c(not.aligned.p.ref.index, t(seq((naa.p.ref + 1), nsites.p.ref)))\n\t  \n\t  r.heme.p.2 = ReadHeme(pdbs.fname, chain.p.2)\n\t  r.p.2 = cbind(r.p.2, r.heme.p.2)\n\t  nsites.p.2 = ncol(r.p.2)\n\t  not.aligned.p.2.index <- c(not.aligned.p.2.index, t(seq((naa.p.2 + 1), nsites.p.2)))\n\t} else {\n\t  nsites.p.ref = naa.p.ref\n\t  nsites.p.2 = naa.p.2\n\t}\n\t\n\t# Rotate r.p.2 minimizing RMSD with P.ref.\n\taligned.p.ref.index3N = c(aligned.p.ref.index * 3,\n\t                          aligned.p.ref.index * 3 - 2,\n\t                          aligned.p.ref.index * 3 - 1)\n\taligned.p.2.index3N = c(aligned.p.2.index * 3,\n\t                        aligned.p.2.index * 3 - 2,\n\t                        aligned.p.2.index * 3 - 1)\n\t\n\tr.p.2 <- matrix(fit.xyz(fixed = as.vector(r.p.ref),\n\t                       mobile = as.vector(r.p.2),\n\t                   fixed.inds = aligned.p.ref.index3N,\n                    mobile.inds = aligned.p.2.index3N), nrow = 3)\n\t\n\t# Calculate dr.\n\tdr = r.p.2[, aligned.p.2.index] - r.p.ref[, aligned.p.ref.index]\n\t\n\t# Cakculate K of p.ref and p.2.\n\tK.p.ref <- CalculateKeff(r.p.ref, \n\t                         aligned.p.ref.index, \n\t                         not.aligned.p.ref.index,\n\t                         CalculateK,\n\t                         CalculateKij, \n\t                         R0, \n\t                         TOLERANCE)\t\n\tK.p.2 <- CalculateKeff(r.p.2, \n\t                       aligned.p.2.index,\n\t                       not.aligned.p.2.index, \n\t                       CalculateK,\n\t                       CalculateKij, \n\t                       R0, \n\t                       TOLERANCE)\t\n\t\n\t# Calculate nmodes.\n\tnmodes <- length(K.p.ref$va)\n\t\n\t# Calculate % sequence identity between p.ref and p.2.\n\tID.p.2 <- CalculateID(df.alignment)\n\t\n\t# Calculate measures of variability.\n\tVA <- CalculateVariability(dr, K.p.ref, K.p.2)\n\tm.ID[P] = ID.p.2\n  m.laligned[P] = naligned \n  m.nH[P, 1:nmodes] = t(VA$nH)\n  m.Pn[P, 1:nmodes] = t(VA$Pn)\n  m.d.evalues[P, 1:nmodes]  = t(VA$d.evalues[1:nmodes])\n\tm.evalues[P, 1:nmodes]  = t(K.p.ref$va[1:nmodes])\n\tdr.squarei = rbind(VA$dr.squarei, aligned.p.ref.index)\n\tfor (i in (1:naa.p.ref)){\n\t\tm.dr.squarei[P, i] = matrix(dr.squarei[1, dr.squarei[2, ] == i], ncol = 1, nrow = 1)\n\t}\n}\n\nP.index = (pdbid != p.ref)\nm.ID <- m.ID[P.index, ]\nm.laligned <- m.laligned[P.index, ]\nm.nH <- m.nH[P.index, ]\nm.Pn <- m.Pn[P.index, ]\nm.d.evalues <- m.d.evalues[P.index, ]\nm.evalues <- m.evalues[P.index, ]\nm.dr.squarei <- m.dr.squarei[P.index, ]\n\n# Calculate means.\nmean.nH = colMeans(m.nH, na.rm = T)\nmean.Pn = colMeans(m.Pn, na.rm = T)\nmean.d.evalues= colMeans(m.d.evalues, na.rm = T)\nmean.evalues= colMeans(m.evalues, na.rm = T)\nMSDi = colMeans(m.dr.squarei, na.rm = T)\nMSD = rowMeans(m.dr.squarei, na.rm = T)\n\n# Save information.\nif (family == \"globins\") {\n  family <- paste(family, \"_heme_\", heme, sep = \"\")\n}\nwrite.csv(m.laligned, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_m.laligned.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(m.ID, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_m.ID.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(m.nH, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_m.nH.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(m.Pn, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_m.Pn.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(m.d.evalues, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_m.d.evalues.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(m.evalues, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_m.evalues.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(m.dr.squarei, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_m.dr.squarei.csv\", sep = \"\")), row.names = FALSE)\n\nwrite.csv(mean.nH, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_nH.mean.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(mean.Pn, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_Pn.mean.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(mean.d.evalues, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_d.evalues.mean.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(mean.evalues, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_evalues.mean.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(MSDi, file = file.path(out.dir, paste(family, \"_core_\", core, \"_out_MSDi.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(MSD, file = file.path(out.dir, paste(family , \"_core_\", core, \"_out_MSD.csv\", sep = \"\")), row.names = FALSE)\nwrite.csv(input, file = file.path(out.dir, paste(family , \"_input\", sep = \"\")), row.names = FALSE)\n",
    "created" : 1447078319030.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1050329405",
    "id" : "BE803DF9",
    "lastKnownWriteTime" : 1447079678,
    "path" : "C:/Users/Laurita/Desktop/Doctorado/VariabilidadEstructuralProteica/ExperimentalMain.R",
    "project_path" : "ExperimentalMain.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}