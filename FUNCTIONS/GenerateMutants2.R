# Description:
#
# This function generates multiple mutants of a given protein using the LF-ENM ("Linearly Forced - Elastic Network Model")
# and considering additive single mutations. It calculates the probability of acceptance of each single mutation
# following the "Stress Model" and using 4 different values of the parameter "beta" for not selection, weak selection,
# mild selection and stong selection. Then, the function accepts each mutation according to the calculated probability. 
# For each protein of the family of the given protein, the program calculates a lineage of simulated mutants with the same
# % of sequence identity.
#
# Usage:
#
# GenerateMutants(family, chain.p.ref, n.mut.p, fmax, R0, heme = TRUE/FALSE, data.dir, out.dir,
# mut.fname.id, TOLERANCE)
#
#  Args:
#    - family: the family of the protein to mutate. It can be "globins", "serinProteases", 
#    "snakesToxin", "sh3", "fabp", "rrm", "phoslip" or "cys".
#    - chain.p.ref: the chain of p.ref in the pdb file obtained from Homstrad.
#    - n.mut.p: the number of mutants to generate for each member of the family. For example, if the family has 20 
#    members, the function generates n.mut.p x 20 mutants.
#    - fmax: It is the maximun value for the forces that model the mutations.
#    - R0: the cut-off for the ANM ("Anisotropic Network Model") that represents the proteins.
#    - heme: argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - data.dir: directory of the data. It must contain the pdb file obtained from Homstrad ("data.dir/family_coordinates.csv").
#    - out.dir: output directory. It must contain the output generated by the function AnalyzeFamily().
#    - mut.fname.id: ID for output filenames.
#    - TOLERANCE: 0 tolerance.
#
#  Required libraries:
#    {Bio3d}
#
#  Required function:
#    ReadCA()
#    ReadHeme()
#    CalculateENMK()
#    CalculateForce()

GenerateMutants <- function(family,
                            chain.p.ref,
                            n.mut.p,
                            fmax, 
                            R0,
                            heme,
                            data.dir,
                            out.dir,
                            mut.fname.id,
                            TOLERANCE) {
  
  
  ### READ EXPERIMENTAL DATA ###
  
  # Filenames.
  m.identity.fname <- file.path(out.dir, paste(family, "_out_m.identity.csv", sep = ""))
  pdbs.fname <- file.path(data.dir, paste(family, "_coordinates.pdb", sep = "")) 
  
  # Read the file with % sequence identity between p.ref and the other proteins of the family.
  m.identity = read.csv(m.identity.fname)$V1
  
  # Calculate the number of proteins of the family.
  n.prot = length(m.identity)
  
  # Read PDB of p.ref.
  pdb = ReadCA(pdbs.fname, chain.p.ref)
  r.p.ref = pdb$xyz.calpha
  n.aa = pdb$n.sites
  
  # Get heme coordinates, add them to CAÂ´s coordinates and calculate the new number of sites.
  if (heme == "TRUE") {
    r.heme = ReadHeme(pdbs.fname, chain.p.ref)
    r.p.ref = cbind(r.p.ref, r.heme)
    n.sites = ncol(r.p.ref)
  } else {
    n.sites = n.aa
  }
  
  
  ### CALCULATE ENM OF THE REFERENCE PROTEIN ###
  
  # Calculate K of p.ref.
  ENMK.p.ref = CalculateENMK(r.p.ref, CalculateKij, R0, TOLERANCE)
  
  
  ### CALCULATE PARAMETERS FOR THE SELECTION OF MUTANTS FOLLOWING THE "STRESS MODEL" ###

  # Calculate mean.CN.
  mean.CN = mean(colSums(ENMK.p.ref$kij))
  
  # Calculate f2 (see the function CalculateForce()).
  f2 = mean((fmax * runif(1e6, -1, 1)) ^ 2)
  
  # Caculate betas for differente selection regimes.
  beta.0.2 = - log(0.2) / (f2 * mean.CN) # Strong selection.
  beta.0.5 = - log(0.5) / (f2 * mean.CN) # Mild selection.
  beta.0.8 = - log(0.8) / (f2 * mean.CN) # Weak selection.
  beta.1 = - log(1) / (f2 * mean.CN) # No selection.
  
  # Build a list with betas.
  all.betas = list("strong.sel" = beta.0.2, "mild.sel" = beta.0.5, "weak.sel" = beta.0.8, "no.sel" = beta.1)
  
  
  ### GENERATE MUTANTS ###
  
  # Start a loop to generate mutants with the differente selection regimes.
  for (beta in (all.betas)) {
    
    # Create a matrix to save coordinates of each mutant.
    m.r.mut = matrix(0, nrow = 3 * n.sites, ncol = n.prot * n.mut.p)
  
    # Create veactors to save simulated and accepted mutations of each mutant.
    v.n.accept.mut = c()
    v.n.mut = c()
    
    # Start a loop for each protein of the family to crate a lineage.
    for (P in (1:n.prot)) {
      
      # Get de sequence identity and the number of mutated sites of "p.ref" for "P".
      identity = m.identity[P]
      n.sites.mut = as.integer((100 - (identity)) * n.aa / 100)
      
      # Start a loop to generate "n.mut.p" mutants for P.
      for(mut in seq(n.mut.p)) {
        
        print(list("beta" = beta, "P" = P, "mut" = mut))
        
        # Start a counter for simulated and accepted mutants.
        n.mut = 0
        n.accept.mut = 0
        
        # Start "dr.tot".
        dr.tot = 0
        
        # Start a loop to simulate single mutations. The " * 10" is to be sure we will have enough attempts for the cases of strong selection. 
        for (l in (1:(n.sites.mut * 10))) {
          
          # Count the number of simulated mutants.
          n.mut = n.mut + 1
          
          # Get the index to mutate from a uniform distribution between 1 and the number of aminoacids.
          mut.index = as.integer(runif(1, 1, n.aa))
      
          # Calculate forces.
          force = CalculateForce(mut.index, r.p.ref, ENMK.p.ref$kij, fmax)
          f = force$f
          sum.fij.square = force$sum.fij.square
      
          # Calculate the acceptance probability of the mutation.
          p.accept.mut = exp (- beta * sum.fij.square)
      
          if (p.accept.mut >= runif(1, 0, 1)) {
            
            # Add to accepted mutants.
            n.accept.mut = n.accept.mut + 1
            
            # Calculate "dr.mut" and "dr.tot".
            dr.mut = ENMK.p.ref$cov %*% f
            dr.tot = dr.tot + dr.mut
          }
          
          # Stop the loop when the number of accepted mutants equals the number of mutated sites in the lineage.
          if (n.accept.mut == n.sites.mut){
            break
          }
        }
        
        # Save n.accept.mut and n.mut for mut.
        v.n.accept.mut = c(v.n.accept.mut, n.accept.mut)
        v.n.mut = c(v.n.mut, n.mut)
        
        # Calculate "r.mut".
        r.mut = as.vector(r.p.ref) + dr.tot
      
        # Keep "r.mut" in a matrix.
        m.r.mut[, n.mut.p * P - (n.mut.p - mut)] = r.mut
      }
    }
    
    
    ### SAVE INFORMATION IN FILES ###
    
    # Create a file to save the data.
    write.csv(m.r.mut, file = file.path(out.dir, paste(mut.fname.id, "beta", beta, "_out_m.r.mut.csv", sep = "")), row.names = FALSE)
    write.csv(v.n.mut, file = file.path(out.dir, paste(mut.fname.id, "beta", beta, "_out_v.n.mut.csv", sep = "")), row.names = FALSE)
    write.csv(v.n.accept.mut, file = file.path(out.dir, paste(mut.fname.id, "beta", beta, "_out_v.n.accept.mut.csv", sep = "")), row.names = FALSE)
  }
  # Create a file to save "r.p.ref".
  write.csv(as.vector(r.p.ref), file = file.path(out.dir, paste(mut.fname.id, "_out_r.p.ref.csv", sep = "")), row.names = FALSE)
}




