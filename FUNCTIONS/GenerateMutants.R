# Description:
#
# This function generates multiple mutants of a given protein using the LF-ENM ("Linearly Forced - Elastic Network Model")
# and considering additive single mutations. It calculates the probability of acceptance of each single mutation
# following the "Stress Model" and a given value of the parameter "beta". The function accepts each mutation according to the calculated probability. 
# For each protein of the family of the given protein, the program calculates a lineage of simulated mutants with the same
# % of sequence identity.
#
# Usage:
#
# GenerateMutants(family, chain.p.ref, n.mut.p, fmax, R0, beta, heme = TRUE/FALSE, data.dir, out.dir,
# mut.fname.id, TOLERANCE)
#
#  Args:
#    - family: the family of the protein to mutate. It can be "globins", "serinProteases", 
#    "snakesToxin", "sh3", "fabp", "rrm", "phoslip" or "cys".
#    - chain.p.ref: the chain of p.ref in the pdb file obtained from Homstrad.
#    - n.mut.p: the number of mutants to generate for each member of the family. For example, if the family has 20 
#    members, the function generates n.mut.p x 20 mutants.
#    - fmax: It is the maximun value for the forces that model the mutations.
#    - R0: the cut-off for the ANM ("Anisotropic Network Model") that represents the proteins.
#    - beta: parameter for the selection following the Stress Model.
#    - heme: argument for "globins". It can be "TRUE" or "FALSE". If it is "TRUE", the program considers the heme group.
#    - data.dir: directory of the data. It must contain the pdb file obtained from Homstrad ("data.dir/family_coordinates.csv").
#    - out.dir: output directory. It must contain the output generated by the function AnalyzeFamily().
#    - mut.fname.id: ID for output filenames.
#    - TOLERANCE: 0 tolerance.
#
#  Required libraries:
#    {Bio3d}
#
#  Required function:
#    ReadCA()
#    ReadHeme()
#    CalculateENMK()
#    CalculateKij()
#    CalculateForce()

GenerateMutants <- function(family,
                            chain.p.ref,
                            n.mut.p,
                            fmax, 
                            R0,
                            beta,
                            heme,
                            data.dir,
                            out.dir,
                            mut.fname.id,
                            TOLERANCE) {
  
  
  ### READ EXPERIMENTAL DATA ###

  # Filenames.
  m.identity.fname <- file.path(out.dir, paste(family, "_out_m.identity.csv", sep = ""))
  pdbs.fname <- file.path(data.dir, paste(family, "_coordinates.pdb", sep = "")) 
  
  # Read the file with % sequence identity between p.ref and the other proteins of the family.
  m.identity = read.csv(m.identity.fname)$V1
  
  # Calculate the number of proteins of the family.
  n.prot = length(m.identity)
  
  # Read PDB of p.ref.
  pdb = ReadCA(pdbs.fname, chain.p.ref)
  r.p.ref = pdb$xyz.calpha
  n.aa = pdb$n.sites
  
  # Get heme coordinates, add them to CAÂ´s coordinates and calculate the new number of sites.
  if (heme == "TRUE") {
    r.heme = ReadHeme(pdbs.fname, chain.p.ref)
    r.p.ref = cbind(r.p.ref, r.heme)
    n.sites = ncol(r.p.ref)
  } else {
    n.sites = n.aa
  }
  
  ### CALCULATE ENM OF THE REFERENCE PROTEIN ###
  
  # Calculate K of p.ref.
  ENMK.p.ref = CalculateENMK(r.p.ref, CalculateKij, R0, TOLERANCE) 
  
  ### GENERATE MUTANTS ###
  
  # Create a matrix to save coordinates of each mutant.
  m.r.mut = matrix(0, nrow = 3 * n.sites, ncol = n.prot * n.mut.p)
  
  # Create veactors to save simulated and accepted mutations of each mutant.
  v.n.accept.mut = c()
  v.n.mut = c()
    
  # Start a loop for each protein of the family to crate a lineage.
  for (P in (1:n.prot)) {
      
    # Get de sequence identity and the number of mutated sites of "p.ref" for "P".
    identity = m.identity[P]
    n.sites.mut = as.integer((100 - (identity)) * n.aa / 100)
      
    # Start a loop to generate "n.mut.p" mutants for P.
    for(mut in seq(n.mut.p)) {
        
      print(list("beta" = beta, "P" = P, "mut" = mut))
        
      # create a vector with possible sites to mutate.
      sites.to.mutate = seq(n.aa) 
        
      # Start a counter for simulated and accepted mutants.
      n.mut = 0
      n.accept.mut = 0
        
      # Start "dr.tot".
      dr.tot = 0
        
      # Start a loop to generate mutations.
      while (n.accept.mut < n.sites.mut) { 
          
        # Count the number of simulated mutants.
        n.mut = n.mut + 1
          
        # Get the index to mutate between 1 and the number of aminoacids.
        mut.index = sample(sites.to.mutate, 1) 
      
        # Calculate forces.
        force = CalculateForce(mut.index, r.p.ref, ENMK.p.ref$kij, fmax)
        f = force$f
        sum.fij.square = force$sum.fij.square
      
        # Calculate the acceptance probability of the mutation.
        p.accept.mut = exp (- beta * sum.fij.square)
      
        if (p.accept.mut >= runif(1, 0, 1)) {
            
          # Add to accepted mutants.
          n.accept.mut = n.accept.mut + 1
            
          # Calculate "dr.mut" and "dr.tot".
          dr.mut = ENMK.p.ref$cov %*% f
          dr.tot = dr.tot + dr.mut
            
          # Remove "mut.index" from "sites.to.mutate" in order to not to mutate the same site more than once.
          sites.to.mutate = sites.to.mutate[sites.to.mutate != mut.index]
        }
      }
        
      # Save n.accept.mut and n.mut for mut.
      v.n.accept.mut = c(v.n.accept.mut, n.accept.mut)
      v.n.mut = c(v.n.mut, n.mut)
        
      # Calculate "r.mut".
      r.mut = as.vector(r.p.ref) + dr.tot
      
      # Keep "r.mut" in a matrix.
      m.r.mut[, n.mut.p * P - (n.mut.p - mut)] = r.mut
    }
  }
    
  ### SAVE INFORMATION IN FILES ###
    
  # Create files to save the data.
  write.csv(m.r.mut, file = file.path(out.dir, paste(mut.fname.id, "_out_m.r.mut.csv", sep = "")), row.names = FALSE)
  write.csv(v.n.mut, file = file.path(out.dir, paste(mut.fname.id, "_out_v.n.mut.csv", sep = "")), row.names = FALSE)
  write.csv(v.n.accept.mut, file = file.path(out.dir, paste(mut.fname.id, "_out_v.n.accept.mut.csv", sep = "")), row.names = FALSE)
  write.csv(as.vector(r.p.ref), file = file.path(out.dir, paste(mut.fname.id, "_out_r.p.ref.csv", sep = "")), row.names = FALSE)
}




