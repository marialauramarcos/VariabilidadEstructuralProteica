---
title: "Comparaciones Teórico-Experimental"
output: html_document
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, echo = FALSE, message = FALSE)
```

```{r, fig.width = 20, fig.height = 40}
# INFORMACIÓN
#
# Este programa genera un archivo HTLM comparando la divergencia etsructural de
# proteínas experimentales y mutantes teóricas.
# Para correrlo se debe completar un Input ("DATA/comp_input.csv") especificando:
# - family: la familia de proteínas a comparar, debe estar escrita consistentemente 
# con los archivos theoretical_input y experimental_input.
# - p.ref: la proteína dereferencia de la familia, que debe ser escrita 
# consisntentemente con el archivo experimental_input, es decir que debe ser escrita de la 
# forma en la que está escrita en el dataset.
# - heme: solo se utiliza para la familia de las globinas, puede ser "TRUE" o 
# "FALSE" dependiendo de si se quiere considerar o no al grupo HEMO.
# - core: puede ser "TRUE" o "FALSE" dependiendo de si se quiere analizar solo los sectores
# del alineamiento donde no hay gaps. 

# Remove objects.
rm (list = ls())

# Nmodes to analyze.
nmodes1 = 10
nmodes2 = 25
nmodes3 = 100

# Load librarys. 
library(flux)  # function "auc".

# Source functions. 
source("FUNCTIONS/CalculateGroupsMeansQuantiles.R")

# Read Input.
input <- read.csv("DATA/comp_input.csv")

# Layout.
layout(matrix(1:(10 * nrow(input)), 2 * nrow(input), 5, byrow = T), widths = rep(10, 10 * nrow(input)), heights = rep(10, 10 * nrow(input)))

for (f in (1:nrow(input))) { 
  family <- input$family[f]
  p.ref <- input$p.ref[f]
  heme <- input$heme[f]
  core <- input$core[f]

  # Read files and calculate measures.
  ## Read experimental output.
  dir.e <- "OUT/Experimental"
  if (as.character(family) == "globins") {
    family <- paste(family, "_heme_", heme, sep = "")
  }
  family <- paste(family, "_core_", core, sep = "")

  laligned = read.csv(file.path(dir.e, paste(family, "_out_m.laligned.csv", sep = "")))$x
  index <- c()
  for (i in (1:length(laligned))) {
    if (laligned[i] == max(laligned)) {
      index[i] <- i
    }
  }
  index <- index[!is.na(index)]
  
  m.Pne = read.csv(file.path(dir.e, paste(family, "_out_m.Pn.csv", sep = "")))[index, 1:nmodes3]
  Pne.mean = colMeans(m.Pne)
  
  m.Qne = t(apply(m.Pne, 1, cumsum))
Qne.mean = colMeans(m.Qne)

  m.evaluese = read.csv(file.path(dir.e, paste(family, "_out_m.evalues.csv", sep = "")))[index, 1:nmodes3]
  evaluese.mean = colMeans(m.evaluese)
  ievaluese.mean = 1/evaluese.mean
  
  MSD = read.csv(file.path(dir.e, paste(family, "_out_MSD.csv", sep = "")))$x
  
  id = read.csv(file.path(dir.e, paste(family, "_out_m.ID.csv", sep = "")))$x
  id.index = id[index]

  ## Read theoretical output.
  dir.t <- "OUT/Theoretical"
  m.Pnt = read.csv(file.path(dir.t, paste(family, "_out_m.Pn.csv", sep = "")))[, 1:nmodes3]
  evalues = read.csv(file.path(dir.t, paste(family, "_out_evalues.csv", sep = "")))$x[1:nmodes3]
  m.Qnt = t(apply(m.Pnt, 1, cumsum))
  ievalues = 1/evalues

  # Number of t and e proteins.
  nmut = nrow(m.Pnt)
  nexp = length(index)

  # Number of t groups.
  ngroups = as.integer(nmut / nexp)

  # Calculate rho and auc.
  rho.t <- matrix(0, nrow = nmut, ncol = 2)
  auc.t <- matrix(0, nrow = nmut, ncol = 2)

  for (i in (1:nmut)) {
    rho.t[i, 1] <- cor((as.vector(as.matrix(m.Pnt[i, 1:nmodes1])) * evalues[1:nmodes1]), ievalues[1:nmodes1], method = "pearson")	
    rho.t[i, 2] <- cor((as.vector(as.matrix(m.Pnt[i, 1:nmodes2])) * evalues[1:nmodes2]), ievalues[1:nmodes2], method = "pearson")	
    auc.t[i, 1] <- auc(seq(1:nmodes1), m.Qnt[i,1:nmodes1])
    auc.t[i, 2] <- auc(seq(1:nmodes2), m.Qnt[i,1:nmodes2])
  }

  rho.e <- matrix(0, nrow = nexp, ncol = 2)
  auc.e <- matrix(0, nrow = nexp, ncol = 2)

  for (i in (1:nexp)) {
    rho.e[i, 1] <- cor((as.vector(as.matrix(m.Pne[i, 1:nmodes1])) * evaluese.mean[1:nmodes1]), ievaluese.mean[1:nmodes1], method = "pearson")
    rho.e[i, 2] <- cor((as.vector(as.matrix(m.Pne[i, 1:nmodes2])) * evaluese.mean[1:nmodes2]), ievaluese.mean[1:nmodes2], method = "pearson")
    auc.e[i, 1] <- auc(seq(1:nmodes1), m.Qne[i, 1:nmodes1])
    auc.e[i, 2] <- auc(seq(1:nmodes2), m.Qne[i, 1:nmodes2])
  }

  # Calculate groups, means and quantiles.
  Pnt.group <- CalculateGroupsMeansQuantiles(m.Pnt, ngroups, nexp)
  Pnt.group.mean <- Pnt.group$mean.total
  Pnt.group.quantile5 <- Pnt.group$quantile[1, ]
  Pnt.group.quantile95 <- Pnt.group$quantile[2, ] 
  
  Qnt.group <- CalculateGroupsMeansQuantiles(m.Qnt, ngroups, nexp)
  Qnt.group.mean <- Qnt.group$mean.total
  Qnt.group.quantile5 <- Qnt.group$quantile[1, ]
  Qnt.group.quantile95 <- Qnt.group$quantile[2, ]

  # Plots.
  hist(id, main = family, col = "grey", xlab = "% ID con referencia")
  hist(laligned, main = family, xlab = "Número de sitios alineados", col = "grey")
  hist(MSD, main = family, xlab = "MSD", col = "grey")

  plot(Pnt.group.mean, ylab = "Pn promedio", xlab = "nmodo", type = "l", ylim = c(0, 0.07), main = family)
  lines(Pnt.group.quantile5, col = "green")
  lines(Pnt.group.quantile95, col = "green")
  points(Pne.mean, col = "red")
  
  plot(y = Pnt.group.mean, x = ievalues, ylab = "Pn promedio teórico", xlab = "1/evalue", ylim = c(0, 0.07), main = family)
   
  plot(y = Pne.mean, x = ievaluese.mean, ylab = "Pn promedio experimental", xlab = "1/evalue", ylim = c(0, 0.07), main = family)

  plot(density(rho.t[, 1]), col = "blue", ylab = "Frecuencia", xlab = "rho 10 modos", main = family)
  points(x = c(rho.e[, 1]), y = rep(0, nexp), col = "red")

  plot(density(rho.t[, 2]), col = "blue", ylab = "Frecuencia", xlab = "rho 25 modos", main = family)
  points(x = c(rho.e[, 2]), y = rep(0, nexp), col = "red")

  plot(density(auc.t[, 1]), col = "blue", ylab = "Frecuencia", xlab = "auc 10 modos", main = family)
  points(x = c(auc.e[, 1]), y = rep(0, nexp), col = "red")

  plot(density(auc.t[, 2]), col = "blue", ylab = "Frecuencia", xlab = "auc 25 modos", main = family)
  points(x = c(auc.e[, 2]), y = rep(0, nexp), col = "red")
}
```



